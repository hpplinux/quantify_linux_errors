% === Notes from Elvis ===

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The above line is 80 characters long. Try to keep it under this width.

% There are 3 ways of highlighting:
%  o \texttt
%      o Folders
%      o Files
%      o Program names
%  o \emph
%      o Company names
%      o New concepts that are introduced
%  o \textcode (\texttt with grey background)
%      o Commands
%      o Command output

%\chapter
%    \section
%        \subsection
%            \subsubsection
%            \paragraph

% === Setup ===

% Needed and Layout
\documentclass[a4paper,11pt]{report}
\usepackage[utf8]{inputenc} % utf8 encoding
\usepackage{amsfonts}
\usepackage[T1]{fontenc} % use for allowing < and > in cleartext
\usepackage[margin=2.5cm]{geometry}

% Lists
\usepackage{verbatim}   % useful for program listings
\usepackage{enumitem}
\usepackage[ampersand]{easylist}

% Creating more compact lists
\let\olditemize\itemize
\renewcommand{\itemize}{
    \olditemize
    \setlength{\itemsep}{1pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}
}

% Creating blue citations
%\newcommand{\cit}[1]{
    %\textcolor{blue}{\cite{#1}}
%}


% Creating my own inline code font
\newcommand{\textcode}[1]{
    \fboxsep=1pt
    \texttt{\colorbox{gray!20}{#1}}
}

% Recreating the figure thingy
\newcommand{\figa}{
    \begin{figure}[!htpb]
    \centering
}
\newcommand{\figb}[2]{
    \caption{#1}
    \label{#2}
    \end{figure}
}


% Math
\usepackage{mathtools}   % need for subequations
\usepackage{xfrac}       % Fractions  like 1/4 via \sfrac

% Graphics
\usepackage{graphicx}   % need for figures
\usepackage{color}      % use if color is used in text 
\usepackage{xcolor}     % use for text background color
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{float}

% Other
\usepackage{todonotes}
\usepackage{pdfpages}
\usepackage{subcaption}
\usepackage{latexsym}
\usepackage{fixltx2e}    % use for textsubscript
\usepackage{datetime}    % for the \currenttime
\usepackage[titletoc,title]{appendix}
\usepackage[framemethod=tikz]{mdframed}
\usepackage[titletoc,title]{appendix}
\usepackage{epstopdf}

% Code listing
\usepackage{listings} % For inserting code from file (I think)
\usepackage{algorithm}
\usepackage{algpseudocode}
\renewcommand{\algorithmicforall}{\textbf{for each}}
\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\DeclareCaptionFormat{algor}{%
  \hrulefill\par\offinterlineskip\vskip1pt%
    \textbf{#1#2}#3\offinterlineskip\hrulefill}
\DeclareCaptionStyle{algori}{singlelinecheck=off,format=algor,labelsep=space}
\captionsetup[algorithm]{style=algori}

% Citations and refs
\usepackage{hyperref} % Citations and refs are links
\hypersetup{colorlinks=true,citecolor=blue}
\usepackage{cite}


% URLs 
\usepackage{url}
\usepackage[hypcap=true]{caption}


% for the \lstinputlisting for code blocks
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1.0,1.0,1.0}
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=1pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}
\lstset{style=mystyle}

\begin{document}

% Configuration
\setlength{\parindent}{0cm}
\setlength{\unitlength}{1mm}

% Front Page
\date{September 1st 2015\\ IT University of Copenhagen}
\title{A Quantitative Analysis of Warnings in Linux \\ Draft: 
    \today~\currenttime}
\author{Elvis Flesborg\\
\texttt{efle@itu.dk}}
\clearpage\maketitle
\thispagestyle{empty}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           TABLE OF CONTENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\thispagestyle{empty}



\newpage

\setcounter{page}{1}


\begin{abstract}
    \emph{---Leave blank until the end---}

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           INTRODUCTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
Large amount of variability

Software Product Lines

Linux Kernel

42 BUGS paper

During development (stable vs unstable)

Following contributions:

o distribution of warnings in Linux

o difference in stable and unstable

o distribution of subsystems

Research Questions




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           BACKGROUND
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
        \chapter{Background}

A \emph{Linux} operating system is often referring to a a \emph{GNU/Linux} 
operating system, where the Linux part of \emph{GNU/Linux} is the Linux kernel, 
and the \emph{GNU} part is a software bundle with utilities (eg. a shell, a 
compiler, etc...) \cite{gnupack}. Both is 
needed, to have a working operating system. 
\\

This report will only focus on the \emph{Linux kernel}, and not the \emph{GNU} 
bundle.


        \section{The Linux Kernel and Variability}

Many software products are configurable in some way. This creates the 
possibility of tailoring the software to suit different needs. For example 
different kinds of hardware, or different functionalities. 

In Linux this is done before compilation, at a preprocessing step. The Linux 
kernel in its entirety is not a valid program, it will have to be preprocessed 
to make sense of the source code.
This is done by the preprocessing tool (in this case \emph{GCC}).
    \cite[p. 1]{IntDatSPL}
\\

This is also called \emph{variability} in software and a software product of 
this type is called \emph{Software Product Lines} (SPL). When different 
software programs can be derived from the same source code base. 

Software with a high-degree of variability is usually refered to as 
\emph{Variability-Intensive Systems} or \emph{VISs}. Other examples of 
\emph{VISs} are \emph{Eclipse}, \emph{Amazon Elastic Compute Service}, and 
\emph{Drupal Content Management Framework} 
    \cite[p. 1]{VarTesDrupal}
to name a few.
\\

The Linux kernel is very configurable. In the configuration files (the Kconfig 
files), there is a total of 14,387 different features, that can be configured.
    \footnote {14,387 across all architectures, with an average of 9,984 per 
        architecture, and 10,335 for the \texttt{x86} architecture}
It is the open source software product with the highest degree of variability.

This high degree of variability has also had an impact on the use cases for the 
Linux kernel. Linux is used for anything from small embedded devices (like car 
GPSs, and cell phones) to supercomputers.
In fact 98\% of the top 500 supercomputers in the world run a Linux distibution
    \cite{top500}
.
\\

This high variability rate makes maintaining the code somewhat harder to 
grasp, and this makes the code base more error prone. So what you get in 
scalability you pay for in complexity of maintaining the code. 
    \footnote{Refer to Jean's project maybe}
    \footnote{Also refer to a paper that andrzej made about industrial 
        something. It said something about how much more efficient the code was,
        when variability was there.}


        \section{Linux Kernel Development}

\begin{center}
    \emph{
        Comment from the Linux team or something...
    }
\end{center}


        \subsection*{Stable and Mainline tree}

The Linux kernel development cycle has approximately 2$\sfrac{3}{4}$ months 
from one stable release to the next stable release
    \cite{crystalball}
.
In the meantime, \emph{Release Candidates (RCs)}, are released approximately 
once every week.

Then, when the top maintainers of the mainline tree think that the kernel is 
stable enough, a new stable version is created, and the whole process is 
repeated.


        \subsection*{linux-next tree}

Then there is the \emph{linux-next} tree. It is a \emph{git} repository, which 
merges over 200 other \emph{git} repositories
    \cite{nextTrees}
, which 
are all based on the \emph{mainline} tree. The \emph{linux-next} tree is 
merging these other trees every day and the merge conflicts are handled. 
Therefore the \emph{linux-next} tree always contain the newest commits. 

\textcolor{gray}{
This tree will get some bugs fixed sooner than if everyone contributed to the 
mainline and tested on that. Comparing to a stable version, one would suspect 
the \emph{linux-next} tree to have more bugs, since it has not been tested, 
and it is the newest code available, which means more bugs have been inserted.
}

For this thesis project, both the \emph{linux-next} tree and the latest stable 
version is used. As time of data gathering, the latest stable version is 
\emph{4.1.1}.

    \footnote{[Y] http://neuling.org/linux-next-size.html}
    \footnote{http://news.gmane.org/gmane.linux.kernel.next - the linux-next 
        mailing list archive}
    \footnote{[Z] http://kisskb.ellerman.id.au/kisskb/matrix/A}


        \section{Inner Workings of Linux Kernel}

This section will explain in coarse detail, the structure of the Linux kernel.
From the directory structure, over configuration, to compilation of the kernel.


        \subsection{Subsystems}

The directories in the root folder of the Linux kernel source code are called 
\emph{subsystems}. 

% --- Not showing this graph ---
% \figa
%     \includegraphics{plots/subsystemsizes.eps}
% \figb{Visualization of the sizes of the subsystems}{fig:subsystems}
% ---

The \texttt{drivers/} subsystem is by far the largest subsystem. It contains 
all hardware drivers. It is also mostly contributed to by hardware vendors.
    \footnote{Source? and is it true? -What would Greg Kroah Hartman say?}
Since it is the largest subsystem, one could suspect it to contain the most 
errors. And even when taking relative size into account, one could suspect this
on the grounds of the majority of the code being written by hardware vendors.
\\

The \texttt{arch/} subsystem contains architecture specific source code. 
There are 29 architectures in the \texttt{arch/} folder, which is why Linux is 
the operating system, which supports the most architectures in the world.
    \cite{22thbirthday}
.
\\

The \texttt{mm/} subsystem is for memory management, \texttt{security} is 
libraries regarding security, and \texttt{kernel} is the where the kernel 
specific code is. Other subsystems are \texttt{sound/}, \texttt{net/}, and 
\texttt{lib/}

% --- Not showing this graph ---
% \figa
%     \includegraphics{plots/archsizes.eps}
% \figb{The sizes of the different architecture diretories}{fig:archsizes}
% ---


% TODO
\begin{itemize}
    \item \underline{\textbf{TODO}}
    \item talk about allnoconfig alldefconfig in background chapter
    \item mention exactly how many configurations there are. (maybe the report 
        from Andrzej). like 2**11,000
    \item Find out how to find the exact number of possible configurations. It 
        is in some article, I got by Andrzej. Plus maybe SharpSAT.
    \item Explain how to find the number of features by grepping.
    \item Talk about subsystems
    \item Maybe talk about the percentage of code in every subsystems. What is 
        Linux kernel made of?
    \item talk about who contributes to the kernel. (intel, novell). Both in 
        code and money?
    \item mention some more subsystems other than drivers and arch
\end{itemize}


        \subsection{Kconfig - The Language of the Feature Model}

            \paragraph{A feature model} 
is a way of representing all the possible configurations - \emph{the 
configuration space}. It contains all the features with their respective 
options and all the constraints and dependencies.

A feature model can be visualized in a feature diagram. The example given here 
will be tiny compared to that of the Linux kernel. The feature model of the 
Linux kernel is too big to fit in a normal sized report.

See figure \ref{featurediagramphone} for a toy example of a feature 
diagram. It depicts a feature model of a phone configuration, where there are 
some mandatory features and some optional, and also a choice option for the 
screen type. A cross-tree dependency is also present.

There is no consensus on a unified notation for attributes in feature models
    \cite{AAFM}


% The feature diagram
% 80 lines down to \figb
\figa
    \begin{tikzpicture}
        % The top box
        \draw (3,3) rectangle (5,3.6);
        \draw (4,3.3) node {Mobile};

        % Middle words
        \draw (0.00,1.75) node {Calls};
        \draw (3,1.75) node {Screen};
        \draw (6,1.75) node {Media};
        \draw (9,1.75) node {GPS};

        % Middle edges
        \draw (0,2.1) edge (4,3);
        \draw (3,2.1) edge (4,3);
        \draw (6,2.1) edge (4,3);
        \draw (9,2.1) edge (4,3);

        % Middle dots
        \draw[fill=black] (0,2.1) circle (0.1);
        \draw[fill=black] (3,2.1) circle (0.1);
        \draw[fill=white] (6,2.1) circle (0.1);
        \draw[fill=white] (9,2.1) circle (0.1);

        % Middle boxes
        \draw (-1,1.5) rectangle (1,2);
        \draw (2,1.5) rectangle (4,2);
        \draw (5,1.5) rectangle (7,2);
        \draw (8,1.5) rectangle (10,2);

        % Bottom words
        \draw (0,-0.25) node {Color};
        \draw (1.5,-0.25) node {BW};
        \draw (4,-0.25) node {High Definition};
        \draw (7,-0.25) node {Camera};
        \draw (9,-0.25) node {MP3};

        % Bottom edges
        \draw (0,0.1) edge (3,1.5);
        \draw (1.5,0.1) edge (3,1.5);
        \draw (4,0.1) edge (3,1.5);
        \draw (7,0.1) edge (6,1.5);
        \draw (9,0.1) edge (6,1.5);

        % Bottom dots
        %\draw[fill=white] (0,0.1) circle (0.1);
        %\draw[fill=white] (2,0.1) circle (0.1);
        %\draw[fill=white] (4,0.1) circle (0.1);
        \draw[fill=white] (7,0.1) circle (0.1);
        \draw[fill=white] (9,0.1) circle (0.1);

        % The 'or'
        \draw (1.5,0.8) edge [bend right] (3.5,0.8);

        % Bottom boxes
        \draw (-1,-0.5) rectangle (0.8,0);
        \draw (1.1,-0.5) rectangle (1.9,0);
        \draw (2.5,-0.5) rectangle (5.5,0);
        \draw (6,-0.5) rectangle (7.9,0);
        \draw (8.4,-0.5) rectangle (9.6,0);


        % The legend
        \draw[fill=black] (4,-1.5) circle (0.1);
        \draw[fill=white] (4,-2) circle (0.1);
        \draw[right] (4.2,-1.5) node {Mandatory feature};
        \draw[right] (4.2,-2) node {Optional feature};

        \draw (4.0,-2.3) edge (4.2,-2.7);
        \draw (4.0,-2.3) edge (3.8,-2.7);
        \draw (4.1,-2.55) edge [bend left] (3.9,-2.55);
        \draw[right] (4.2,-2.5) node {Choice};

        % The cross-tree dependency
        \draw[right] (-3, -2) node {\textbf{Media} depends on 
            \textbf{High Definition}};

    \end{tikzpicture}
\figb{An example of a feature diagram of a phone}{featurediagramphone}
% 80 lines up to \figa


            \paragraph{The Kconfig language} 
is the language of the feature model in Linux (also used for other projects 
like BusyBox, BuildRoot, CoreBoot, Freetz and others)
    \cite[p. 4]{VarModSSD}
.
The configuration files have the prefix \textcode{Kconfig}, and are 
scattered all over the Linux kernel source code tree, where they include each 
other. There are 1195 Kconfig files in total in the Linux kernel
    \footnote{Found with the command \textcode{find . | grep Kconfig | wc}}
with 956 of them relevant for the \texttt{x86/} architecture.
\\

When a configuration is created, it is saved to a file called \texttt{.config}.
In this file, all features are prefixed with \textcode{CONFIG\_}.

The different data types and the percentage of them in the \texttt{x86} 
architecture are \textcode{boolean} (35\%), \textcode{tristate} 
(61\%), \textcode{string} (0.41\%), \textcode{hex} (0.32\%), and 
\textcode{integer} (3.7\%). For a description of 
the context free grammar of the Kconfig language, see the appendices.
    \footnote{Write the Backus Naur Form of Kconfig in the Appendix}
\\

\figa
    \lstinputlisting[]{code/kconfigphone}
\figb{Kconfig for the phone example}{kconfigphone}

        {\color{gray}
The features in Kconfig can be split into four different types, \emph{User 
features}, \emph{Implementation features}, \emph{Derived features}, and 
\emph{Capability features}
    \cite[p. 8]{VarModSSD}
.
\\ 

\paragraph{User} features are features that the user chooses a value for in the 
configurator. In other words, a feature, that has a prompt option in the 
Kconfig language. 

These features may not directly inflict the compiler's choices, but may only 
open up for other features in the configurator.

\paragraph{Implementation} features are referenced in the source code, and will 
directly influence what code the preprocessor will select for compilation.

\paragraph{Derived} features are invisible to the user, and are set by other 
features using the \textcode{select FOO} syntax.

\paragraph{Capability} features in Linux are features, that simulate a reverse 
dependency. These features are also not randomly chosen by 
    \texttt{randconfig}
        \footnote{Should I give an example here of the capability one?}
    . Their names often start with \textcode{CONFIG\_HAVE\_} or 
    \textcode{CONFIG\_ARCH\_HAVE\_}, and only have \emph{type} option set (often to 
    \texttt{bool}).
            } % color gray

        \footnote{describe that all models are typically wide and shallow, 
        VarModSSD page 19}
        \footnote{write how Kconfig is a beast sometimes. Child nodes exclusding 
        their parents}
        \footnote{How many are there of each of these. distirbution.}


%TODO
\begin{itemize}
    \item Explain the Kconfig language a bit
    \item Reference to Thorsten's projects
    \item Refer to the /Documentation/kbuild/kconfig-language.txt
    \item Should I have the Backus Naur Form of the Kconfig language here?
\end{itemize}

        \subsection{Configuring of Linux}

The Linux kernel comes with different ways of creating your own configuration 
file. There is a question based one: \texttt{config}, and some menu based ones:
\texttt{menuconfig}, \texttt{xconfig}, \texttt{nconfig}, \texttt{gconfig}, 
but also some that will never prompt the user for anything, but create an 
automated config: \texttt{allyesconfig} (enabling as much as possible), 
\texttt{allnoconfig} (disabling as much as possible), \texttt{defconfig} 
(choosing the default values for everything), and \texttt{randconfig} (choosing 
random values for everything).
\\

See figure \ref{fig:lineofconfigs} for a few examples of what the graphical 
configuration tools look like.
\\


\figa
    \includegraphics[scale=0.25]{pngs/configs50percent.png}
\figb{gconfig, menuconfig, nconfig, and xconfig}{fig:lineofconfigs}


%TODO
\begin{itemize}
    \item Talk about how there is 7 layers of dependencies. And how I found out.
    \item \^ Hmm . Are there only 7 layers when counting ifs? what about 
        'depends on's
\end{itemize}


\subsection{Compiling and Catching Errors and Warnings}

The compilation is done mainly by \emph{GCC - The GNU Compiler Collection}
    \footnote{\url{https://gcc.gnu.org}}.

During compilation, \texttt{GCC} will output warnings when there are any
    \footnote{There are on average 12 warning messages per compilation}
.

In a warning, there is information about a possible coding mistake that might 
break the code. There are about 30 different warning types that are enabled by 
default \cite{gccwarnings} Some of them are more severe than others.

The warnings have the output format \textcode{[-Wwarningtype]}, and this is 
output whenever there is a warning. This makes the warnings very easy to 
quantify automatically.
\\

If an error occurs during compilation, \texttt{GCC} will stop, and give an error
message. The error messages though, are not as fulfilling as the warning 
messages. Often an erroneous subprocess will return an errorcode to 
\texttt{GCC}, which will then stop. 

All that is shown is the errorcode, and the directory in which it occured.

    \footnote{example of an error message}
\\

An error need not be a bug in the Linux kernel code. It can be a missing program
on the machine that is compiling the code (the \emph{host machine}). These will
be called \emph{host errors}.
\\




        \subsection{The GCC Warnings}
Here follows a list of the warnings that was found during the compilations. 
They are ordered alphabetically.


            \paragraph{array-bounds}
is given, when GCC is certain that a subscript to an array is always out of 
bounds.

% See example in figure \ref{lst:arraybounds}.

% \figa
    % \lstinputlisting[language=C]{code/arraybounds}
% \figb{}{lst:arraybounds}


            \paragraph{cpp}
will show \textcode{\#warning} directives written in the code. This is a warning
message that the coder can pass to the compiler. Often they will not result in 
an error.


            \paragraph{deprecated-declarations}
will show warnings when functions, variables, or types have been declared 
deprecated be a programmer.


            \paragraph{discarded-array-qualifiers}
            \paragraph{error=}
is a prefix, which means that the warning will cause an error. Sometimes 
developers do not want a specific warning to happen without the compilation 
stopping. Then they can enable this flag in the makefile.

There is also a \texttt{no-error=}, which nullifies the \texttt{error=} flag.


            \paragraph{frame-larger-than=}
            \paragraph{implicit-function-declaration}
            \paragraph{incompatible-pointer-types}
            \paragraph{int-conversion}
            \paragraph{int-to-pointer-cast}
\emph{See the section about pointer-to-int on page \pageref{par:pointertoint}}

            \paragraph{logical-not-parentheses}
occurs when the left hand side of an expression contains a \emph{logical not} 
(a \texttt{!} in C). An example is \textcode{if (!ret == template[i].fail)}
    \footnote{From the file \texttt{crypto/testmgr.c}}
.

The warning refers to the \textcode{!ret}, which should have been inside 
parentheses to be correct, like so \textcode{(!ret)}.


            \paragraph{maybe-uninitialized}
is when there is an uncertainty about a variable being uninitialized. In the 
case in figure \ref{lst:maybeuninitializedreal} there is a 
\texttt{switch-case} where \texttt{sgn} is not initialized in all of the cases.

If \emph{GCC} cannot see for sure that the variable is initialized, 
even if it would have been initialized in all of the cases, it will return this 
warning.

\figa
    \lstinputlisting[language=C]{code/maybeuninitializedreal}
\figb{A real example of maybe-uninitialized function}{lst:maybeuninitializedreal}


            \paragraph{overflow}


            \paragraph{pointer-to-int-cast}
            \label{par:pointertoint}
This warning would normally be sign of bad code. It is usually when a pointer 
is cast to a \texttt{long} and then later cast back into a function call. This 
is widely spread in Linux to simulate the effects of \emph{Object Oriented 
Programming}.
    \footnote{source: Claus... find other source.}


            \paragraph{return-type}
            \paragraph{switch-bool}
            \paragraph{uninitialized}
            \paragraph{unused-function}
is a warning about a function that has never been called. This represents dead 
code, or code pollution. 

In the example in figure \ref{lst:unusedfuncreal}, the function 
\texttt{bq27x00\_powersupply\_unregister} will not be called if the feature 
\texttt{CONFIG\_BATTERY\_BQ27X00\_I2C} is not enabled, and is therefore an 
unused function.

\figa
    \lstinputlisting[language=C]{code/unusedfuncreal}
\figb{A real example of unused function - from the file 
    \texttt{drivers/power/bq27x00\_battery.c}}{lst:unusedfuncreal}


            \paragraph{unused-variable}
is basically the same as \texttt{unused-function}, but only with a variable 
instead of a function. There will be no example of this.


            \paragraph{unused-label}


%TODO
\begin{itemize}
    \item declare each warning either dangerous or not-dangerous.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           METHODOLOGY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\chapter{Methodology}

\emph{Objective:}
The objective is to make a quantitative analysis of warnings in randomly 
generated Linux kernels. The warnings functions as a proxy of errors.
These are the research questions:
\\

\textbf{RQ1:} Will the unstable linux-next repository generate more warnings 
than the stable kernel.
\\

\textbf{RQ2:} In what subsystems do the most errors occur?
\\

\textbf{RQ3:} What warnings are the most common.
\\

\textbf{RQ4:} Is there any significant difference in the warnings in the 
stable versus the unstable.
\\

\textbf{RQ5:} Are there any specific features, that when enabled, will produce 
more warnings than others. 
\\


\emph{Subject:}
There will be generated random configurations, and these will be used to 
compile two different versions of the Linux kernel, a stable Linux kernel 
version \emph{4.1.1}, and a Linux kernel from the \emph{linux-next} repository
    \footnote{Can both be found on \url{https://www.kernel.org}}.
\\

\emph{Methodology:}
The methodology will be in four parts. First part is finding a way of
generating random configurations. Second part is compiling the Linux kernel 
using these configurations while obtaining information about the compilation.
Third part is analyzing this data. Fourth part will answer the research 
Questions based on the analysis.



\section{Generating random configurations}

The configurator \texttt{randconfig} is used in this project. It is used as a 
proxy for totally representative configurations. The truth is that 
\texttt{randconfig} is not representative, but is biased towards features 
higher up in the feature model tree.
\\

See figure ~\ref{randconfigtoy} for a toy example of a Kconfig feature model. 
It is a very small example with only two features, but it will easily explain 
some limitations of using \texttt{randconfig}.

\figa
    \lstinputlisting[language=C, firstline=1, morekeywords={prompt, config, 
        depends, on, bool, endchoice, choice,{||}}]{code/kconfigrandconfigtoy}
\figb{A toy Kconfig feature model}{randconfigtoy}

% --- 33 lines down ---
\figa
    \begin{tikzpicture}
        % Names of configs
        \draw (2,4) node {\textcode{CONFIG\_A}};
        \draw (4,2) node {\textcode{CONFIG\_B}};

        % yeses and nos
        \draw (1,3) node {\textcode{=n}};
        \draw (3,3) node {\textcode{=y}};
        \draw (3,1) node {\textcode{=n}};
        \draw (5,1) node {\textcode{=y}};

        % lines not necessarily from above and down
        \draw[-] (1.9,3.8) edge (1,3.2);
        \draw[-] (2.1,3.8) edge (3,3.2);
        \draw[-] (3,2.8) edge (4,2.2);
        \draw[-] (3,1.2) edge (4,1.8);
        \draw[-] (5,1.2) edge (4,1.8);

        % Draw percentages
        \draw (1,3.5) node {\tiny{50\%}};
        \draw (3,3.5) node {\tiny{50\%}};
        \draw (3,1.5) node {\tiny{50\%}};
        \draw (5,1.5) node {\tiny{50\%}};

        \draw (1,2.5) node {\textbf{\underline{50\%}}};
        \draw (3,0.5) node {\textbf{\underline{25\%}}};
        \draw (5,0.5) node {\textbf{\underline{25\%}}};

        %%%% ==== The next graph ====

        % Names of configs
        \draw (9,4) node {\textcode{CONFIG\_A}};
        \draw (11,2) node {\textcode{CONFIG\_B}};

        % yeses and nos
        \draw (8,3) node {\textcode{=n}};
        \draw (10,3) node {\textcode{=y}};
        \draw (10,1) node {\textcode{=n}};
        \draw (12,1) node {\textcode{=y}};

        % lines not necessarily from above and down
        \draw[-] (8.9,3.8) edge (8,3.2);
        \draw[-] (9.1,3.8) edge (10,3.2);
        \draw[-] (10,2.8) edge (11,2.2);
        \draw[-] (10,1.2) edge (11,1.8);
        \draw[-] (12,1.2) edge (11,1.8);

        % Draw percentages
        \draw (8,3.5) node {\tiny{33\%}};
        \draw (10,3.5) node {\tiny{66\%}};
        \draw (10,1.5) node {\tiny{50\%}};
        \draw (12,1.5) node {\tiny{50\%}};

        \draw (8,2.5) node {\textbf{\underline{33\%}}};
        \draw (10,0.5) node {\textbf{\underline{33\%}}};
        \draw (12,0.5) node {\textbf{\underline{33\%}}};
    \end{tikzpicture}
\figb{(left) How \texttt{randconfig} will select (right) Representative 
    selection}{randconfigtoy50}
% --- 33 lines up ---

The example in figure ~\ref{randconfigtoy50}(left) shows that the three possible
configurations (\texttt{\{\}}, \texttt{\{A\}}, and \texttt{\{A,B\}}) do 
not have the same chance of getting created by \texttt{randconfig}.

For the creation to be representative, all the three possible configurations 
should have equal chance of being created (33\%). See figure 
~\ref{randconfigtoy50}(right) for a visualization of how the selection should 
be to be representative.


Representativeness does not matter for the Linux kernel developers, the 
\texttt{randconfig} function is merely used as a simple fuzz testing tool
    \footnote{source}
.

This ultimately means that \texttt{randconfig} is not representative in its 
configuration creation. more about representativeness in the section 
\ref{rephunt}.
\\

Even though \texttt{randconfig} generates valid configurations, there were still
some features that showed to be creating bogus errors.
\\

For instance, there is a feature in the feature model that is called 
\textcode{CONFIG\_KERNEL\_LZO}, which enables kernel compression with the 
\emph{LZO library}.

If the \emph{LZO library} is not installed on the host machine, then the 
compilation will fail.
\\

There exist many other examples like this in the Linux kernel where an 
uninstalled program will result in an unbuilt kernel. These \emph{host 
errors} would have to be minimized, since they are not actual kernel errors, 
but local errors. 

On the build system for this project, the \emph{lzo} package was in the Linux 
distribution's repository, and therefore easy to install. The \emph{lz4} 
package however was not.
    \footnote{be sure of that the warnings are ONLY for the linux kernel and
        not \emph{host warnings}}
\\

The following is a list of mandatory features, which are added to decrease the 
amount of host errors. In an early period of the project, it was found out that 
these specific features with specific values would stop the compilation every 
time.

It decreases the configuration space of this project, but otherwise 
would just give a lot of false positives.
\\

All these lines are added to the configurations, which are generated in
this project.

\begin{itemize}
    \item \textcode{CONFIG\_STANDALONE=y}
    \item \textcode{CONFIG\_FW\_LOADER=n}
    \item \textcode{CONFIG\_SECCOMP=y}
    \item \textcode{CONFIG\_PREVENT\_FIRMWARE\_BUILD=y}
    \item \textcode{CONFIG\_*LZ4*=n}
        \footnote{This means that all features having to do with \emph{lz4} 
                    were disabled}
\end{itemize}

See chapter~\ref{ch:ttv} about Threats to Validity on page \pageref{ch:ttv} 
for a more thorough description of the specific features.


    \subsection{The Hunt for Representativeness}
    \label{rephunt}
To make the sample of configurations representative, three different ways were
thought of, and researched if feasible. They were \emph{changing randconfig}, 
\emph{permuting Kconfig}, and \emph{generate and filter}.
\\

To change \texttt{randconfig} to be representative, one would have to make 
it aware of the whole dependency tree before randomly selecting features. This 
seems infeasible since the configuration space is so large. It will not fit in 
memory.
\\

Another idea was to \emph{permute the Kconfig} files. First by desugaring the 
Kconfig files to be in one \emph{level} only
    \footnote{For example by replacing \textcode{if FOO} clauses by 
    \textcode{depends on} options in the features clauses.}
, and then randomly scramble the feature 
clauses in the files. If the \texttt{randconfig} script then loads the Kconfig
files from the top to the bottom, it will 'flip the coin' starting a random 
place each time.

This did not work, as \texttt{randconfig} did not flip the coin when reading 
the Kconfig files. Rather, it read the Kconfig files, and then 'flipped the 
coin' on the dependency tree.
\\

The last way of generating a representative sample of configurations was a 
method which was dubbed \emph{generate and filter}. 

\texttt{.config} files were generated, and the invalid ones were 
filtered away. Only the valid configurations were compiled.
\\

In the generation process, some mandatory features were given fixed values
    \footnote{These were, among few others, features from the 
    \texttt{allnoconfig}}
. All other values were randomly generated.

Unfortunately this method never did find a valid configuration even after 
generating 100,000 configurations.
\\

Since none of the three proposed methods worked, \texttt{randconfig} became the 
preferable choice.


\section{Compiling}
When a configuration has been created, the Linux kernel is compiled using 
that configuration file by running the command \textcode{make all}. This 
command runs \emph{GNU Make}, which is instructed how to compile the kernel with
\emph{GCC - The GNU Compiler Collection}.
\\

\emph{GCC} will output warnings and error messages, which is saved for analysis.




\iffalse % This will be commented out.
    \paragraph{The relevant warnings}
are warnings that may cause an error at some point. The \emph{uninitialized 
variable} warning is such a warning. If a variable is uninitialized, and ends 
up being called, it may cause an error, and stop the compilation. See figure 
\ref{lst:uninitvar} for a code example.

The relevant warnings are:

\begin{itemize}
    \item Uninitialized variable
    \item Maybe uninitialized
    \item Overflow
    \item Deprecated declarations
        \footnote{Complete this list}
\end{itemize}

\figa
    \lstinputlisting[language=C, firstline=3]{code/uninitvar.c}
\figb{A toy program showing an uninitialized variable.}{lst:uninitvar}

If \textcode{CONFIG\_A} is not enabled in the program in figure 
~\ref{lst:uninitvar} it will return the warning 
'\texttt{'n' is used uninitialized in this function [-Wuninitialized]}' and the 
output, when the program is run, will be '\texttt{0Hello world}',
which is wrong, as the program was meant to output '\texttt{Hello World}'.

    \paragraph{The irrelevant warnings}
are warnings that will not stop the compilation, and will not make the program 
output wrong things. Warnings like \emph{unused function}, \emph{unused 
variable}, \emph{unused label}, and \emph{unused value}, will all end up as 
dead code, which is bad for fitting a kernel on some hardware with limited 
space. Apart from that it is nothing else than code pollution. See figure 
~\ref{lst:unusedvar} for a code example  of an unused variable.

The irrelevant warnings are:

\begin{itemize}
    \item Unused function
    \item Unused variable
    \item Unused label
    \item Unused value
        \footnote{Complete this list}
\end{itemize}

\figa
    \lstinputlisting[language=C, firstline=3]{code/unusedvar.c}
\figb{A program resulting in an unused variable warning.}{lst:unusedvar}

This will return the warning '\texttt{unused variable 'n' [-Wunused-variable]}'.

\fi % iffalse

\section{Collecting and Analyzing Data}

Every time a randomly configured compilation is running, \emph{GCC} will 
output warning and error messages in the \emph{standard error} output. This 
output is then scraped through to categorize it.

An output line will contain a \emph{bug type}, a \emph{filename}, \emph{line 
number}, and a \emph{message} describing the warning in english.


The collection of data has mainly been done on a computer at the IT University 
of Copenhagen. The computer has $32\times2.8 MHz$ and $128 GB$ of RAM, and the 
average time to compile a kernel and upload the data was around 1 minute and 35 
seconds. A fairly regular laptop with 4 cores and 8 GB of RAM does that in just 
over 8 minutes on average. 
\\


When a compilation is done, the output is scraped and categorized, and then 
uploaded to a database, for easy querying during and after the project. 

See the figures ~\ref{fig:conftable}, ~\ref{fig:bugstable}, and 
~\ref{fig:filestable} for the database tables.


\figa
    \begin{tabular}{c|c|c}
        \hline 
        \hline
        \multicolumn{3}{c}{\textbf{Configurations}} \\
        \hline
        \textbf{Name} & \textbf{Type} &\textbf{primary key} \\
        \hline
        hash & char(64) & primary key \\
        exit\_status & int(1) \\
        conf\_errs & text \\
        linux\_version & varchar(100) & primary key \\
        original & longtext \\
        \hline
        \hline
    \end{tabular}
\figb{The Configurations table}{fig:conftable}

\figa
    \begin{tabular}{c|c|c}
        \hline
        \hline
        \multicolumn{3}{c}{\textbf{Bugs}} \\
        \hline
        \textbf{Name} & \textbf{Type} &\textbf{primary key} \\
        \hline
        hash & char(64) & primary key \\
        type & varchar(50) \\
        linux\_version & varchar(100) \\
        config\_hash & char(64) \\
        subsystem & varchar(30) \\
        original & longtext \\
        \hline
        \hline
    \end{tabular}
\figb{The Bugs table referring to the Configurations table}{fig:bugstable}

\figa
    \begin{tabular}{c|c|c}
        \hline
        \hline
        \multicolumn{3}{c}{\textbf{Files}} \\
        \hline
        \textbf{Name} & \textbf{Type} &\textbf{primary key} \\
        \hline
        id & int(11) & primary key \\
        path & varchar(50) \\
        line & varchar(15) \\
        bug\_id & char(64) \\
        \hline
        \hline
    \end{tabular}
\figb{The Files table referring to the Bugs table}{fig:filestable}

% TODO
\begin{itemize}
    \item Tell about coccinelle, and why we dont use that
\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               RESULTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\chapter{Results}

A total of 42,060 configurations were compiled. Half of them from the unstable 
(linux-next) Linux version, and the other half a stable version of Linux 
(version 4.1.1).

    \section{Errors}

Out of 21,030 compilations, 7911 (38\%) of the unstable ones had an error and 
stopped. For the stable ones, it was 3611 (17\%), which had an error.

    \subsection{Stable}

Out of the 17\% of the compilations, that had errors, here is a sorted list of 
the warnings. To know exactly which warning is 'responsible' for the error, 
one would have to look into every case, and find out.
    \footnote{refer to GNU GCC warning options and also refer to the figure 
        underneath}


\figa
    \begin{tabular}{c|c}
        \hline 
        \hline

        \textbf{Warning type} & \textbf{Percent} \\

        \hline

        unused-function & 57\% \\
        maybe-uninitialized & 45\% \\
        unused-variable & 35\% \\
        logical-not-parentheses & 34\% \\
        error=implicit-function-declaration & 27\% \\
        frame-larger-than= & 24\% \\
        cpp & 23\% \\
        pointer-to-int-cast & 20\% \\
        discarded-array-qualifiers & 19\% \\
        switch-bool & 17\% \\
        int-conversion & 14\% \\
        array-bounds & 14\% \\
        return-type & 12\% \\
        uninitialized & 12\% \\
        overflow & 11\% \\
        unused-label & 8.1\% \\
        deprecated-declarations & 5.4\% \\
        int-to-pointer-cast & 4.5\% \\
        implicit-function-declaration & 1.7\% \\
        incompatible-pointer-types & 0.44\% \\
        error=implicit-int & 0.17\% \\

        \hline 
        \hline
    \end{tabular}
\figb{The warnings distribution of the stable Linux of the compilations with 
    errors}{tab:stablewarnwitherrs}


    \subsection{Unstable vs.Stable}


    \section{Warnings}

In this section, it will be the warning distribution, not only for the ones 
with errors, which stopped compiling, but for all of the compilation.


    \subsection{Stable}

\figa
    \begin{tabular}{c|c}

    \end{tabular}
\figb{The warnings distribution of the stable Linux}{tab:stablewarn}


    \subsection{Unstable vs.Stable}


    \subsection{Subsystems With Errors}



\figa
    \begin{tabular}{c|c|c|c}
        \hline
        \hline
        ss     & errors  & loc [M]     & err/loc \\
        \hline 
        usr     & 2471    & 845          & 290 \% \\
        samples & 2471    & 7,500        & 32\% \\
        include & 2421    & 692,000      & 0.35 \% \\
        drivers & 1405    & 10,800,000   & 0.013 \% \\
        lib     & 99      & 1,050,00     & 0.094 \% \\
        init    & 1       & 5,730        & 0.017 \% \\
        ipc     & 1       & 8,860        & 0.011 \% \\
        net     & 88      & 890,000      & 0.0099 \% \\
        crypto  & 8       & 83,900       & 0.0095 \% \\
        arch/x86 & 26     & 343,000      & 0.0076 \% \\
        scripts & 5       & 90,700       & 0.0055 \% \\
        sound   & 26      & 876,000      & 0.0030 \% \\
        mm      & 3       & 108,000      & 0.0028 \% \\
        fs      & 31      & 1,170,000    & 0.0026 \% \\
        kernel  & 6       & 244,000      & 0.0025 \% \\
        arch    & 26      & 3,440,000    & 0.00076 \% \\
        firmware & 0       & 129,000      & 0.00046 \% \\
        virt    & 0       & 10,500       & 0    \% \\
        tools   & 1       & 218,000      & 0    \% \\
        block   & 0       & 38,100       & 0    \% \\
        security & 0       & 75,500       & 0   \% \\
        \hline
        \hline
    \end{tabular}
\figb{}{}

\figa
    \begin{tabular}{l|r}
        \hline
        \hline
        \textbf{Subsystem} & \textbf{Percent} \\
        \hline
        
        samples & 68\%\\
        usr     & 68\%\\
        include & 67\%\\
        drivers/    &   39\% \\
        lib     & 2.7\%\\
        net     & 2.4\%\\
        fs/         & 0.86\% \\
        sound   & 0.72\%\\
        arch/   & 0.71\%\\
        crypto/ & 0.22\%\\
        kernel  & 0.17\%\\
        scripts & 0.13\%\\
        mm/ & 0.083\% \\
        init    & 0.028\%\\
        ipc     & 0.028\%\\
        security & 0.0\%\\
        block/  & 0.0\%\\

        \hline
        \hline
        
    \end{tabular}
\figb{Percentage of subsystems that were present in errorneous compilations}{}


\section{Analyzing the data}


    \section{Number of valid configurations}

There was a hope, that something could be said about the percentage of valid 
configurations out of all possible combinations.

Some mandatory features were fixed, and an experiment was run, but after 100,000
configurations, none of them were valid. This can only be used to say something
about the upper bound of the percentage.


\section{Observations}


    \subsection{Configuration Warnings}
When creating a random configuration, 25\%
    \footnote{get the correct percentage}
of the times, it will output a warning about unmet dependencies. One might
suspect that configurations, which yielded a warning would result in
compilation errors. 

As can be seen in figure \ref{tbl:confwarns}, fewer of the stable kernels that 
had configuration warnings also had an error in the compilation. But the rise 
in erroneous compilations from configurations without config warnings to 
configurations with config warnings is very little, and is claimed irrelevant.

\figa
    \begin{tabular}{c|c|c}
    \hline
    \hline
        & \textbf{Stable} & \textbf{Unstable} \\
    \hline
    No config warnings & 17\% & 36\%\\
    Config warnings & 19\% & 40\%\\
    \hline
    \hline
    \end{tabular}
\figb{Percentage of the configs with and without warnings, which resulted in an 
    erroneous compilation}{tbl:confwarns}

% TODO
\begin{itemize}
    \item \underline{\textbf{TODO}}
    \item write how many bugs/config on average there were.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           THREATS TO VALIDITY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
    \chapter{Threats to Validity}
\label{ch:ttv}

\emph{Blahblah about Threats to validity...}

\section{Generalization}
\label{sec:gen}

One major threat to validity is in the representativeness of the random 
configurations. Since the configurations are created using the \textcode{make 
randconfig} method, some configurations are more likely to be generated than 
others.

This means, that when something is generally said about all of the Linux 
Kernel, instead something is said about mostly a subset of Linuxes. See figure 
\ref{fig:repsubset} for a visualization of subsets which are both 
representative, and not representative.

\figa
    \emph{Show an image of true representativeness}
\figb{A representative subset}{fig:repsubset}

Three ways was thought of, that would make the configurations more 
generalizable. If successful with any of the methods, they could have been 
committed to the Linux kernel. Unfortunately, none of them were successful.


    \subsection*{Changing the code of \texttt{randconfig}}
The first idea was to change the code of \texttt{randconfig}, so it would know
what the possibilities of each outcome should be. See figure 
\ref{randconfigtoy33} for a visualization.

This was deemed impossible due to the very large feature model. The 
\emph{Abstract Syntax Tree (AST)} would simply not fit in memory of any 
computer.
    \footnote{Give short example}


    \subsection*{Permutation of Kconfig files}
Another idea was to take all the spread out Kconfig files, and concatenate 
them all into one big text file, which would then be modified and exposed to 
syntactic desugaring. If the order of the features were randomized, then the 
coins would not be flipped in the same order every time, and this could have an 
effect on the dependent features. 
\\

It turned out, that \texttt{randconfig} does not regard the order of the 
kconfig files. The Kconfig files are loaded, and \texttt{randconfig} then 
utilizes the AST and randomly selects from the root of that, which gives the
same result as when Kconfig is not permuted.


    \subsection*{Generate and Filter}
The third idea was to manually generate a configuration file, and then check - 
somehow - if the config file was valid, and then use it if it was valid. By 
not looking at dependencies, but only considering \emph{choice} options and 
enabling \emph{mandatory features}, a configuration file was created by 
randomly flipping a coin per each feature.

This seemed doable, but after generating 100,000 configurations, not one 
valid configuration was found.

It was considered running \emph{SharpSAT} (or \emph{\#SAT}) to count the number
of valid configurations, but it was deemed out of scope of this project.
    \footnote{Link to sharpSAT thingy}


    \subsection{Features in Stable vs. Unstable}
In the unstable Linux version, there are 20 more features than in the stable 
one. This means that there is a possibility that errors might happen in this 
new code.

Configurations are created in the unstable version, and when the stable version 
runs the same configuration file, it will just disregard these unknown features.
\\

If it was done the other way around, the unstable version would always set the 
new features to the default value, and they would therefore not be randomized.


    \subsection{Gcc versions}
Roughly a third of the compilations were done with GCC version 5.1.0 and two 
thirds with GCC version 4.9.2. This should not matter on what warnings are 
returned. There is only one new warning that is enabled by the \texttt{-Wall} 
flag in version 5.1.0
    \footnote{\texttt{-Wc++14compat}}
, and none of this type was found.


    \subsection{Architecture}

To create a true representative sample space, all the different architectures 
should be compiled for. There exist 31 different architectures, but the most 
common one for laptop and server use is the \texttt{x86} architecture.

This architecture is the only one, that are compiled for in this project, as 
getting the cross compilers for all the different architectures would be very 
cumbersome. 
\\


This potentially leaves out 97\% \footnote{is this number true. Should I 
calculate?} of the possible configurations to check.

\subsection{Firmware}

Some places in the kernel, there are drivers, which rely on some external 
proprietary binary blob, before they can be built. These binaries are not in 
the kernel, but would have to be downloaded specifically and put in certain 
folders in the kernel tree.

These are throwing errors, which are local errors, and therefore invalid. The 
task of getting all the drivers into the kernel tree was too great, so instead, 
those configurations are simply skipped.

This gives another bias in the sample, which now does not contain any 
configurations with these features on.


% --- 19 lines copied from further up
The feature \textcode{CONFIG\_STANDALONE} for instance, has been enabled in all 
the configurations in this project. If this feature is disabled, it allows for 
firmware drivers to be compiled in the kernel. But these firmware drivers are 
not open source, and must be placed in the kernel directories manually for the 
compilation to work.

Since it would be too cumbersome to find all the proprietary drivers, this 
option of enabling the \textcode{CONFIG\_STANDALONE} feature has been chosen, 
and will commit to a threat to validity in respect to representativeness.
\\

Also every feature that had some relation to the \emph{z4c} library has been 
diabled. This would require the host \footnote{explain what a host and target 
are at some point further up} to have this library installed. This library was 
not in the Linux distribution's repository, and it would have been too time 
consuming to have it installed. 

Therefore this also marks as a threat to validity.
% ---- 19 lines

\begin{itemize}
    %\item Only run on x86 architecture
    \item randconfig bias
    %\item firmware blobs
    \item Internal vs. External validity
    \item The mandatory features?
\end{itemize}

\section{Generate'n'Filter}



\begin{itemize}
    \item Uniform distribution
    \item Too low percentage
    \item Get a lower bound on the percentage
    \item sharpSAT?
\end{itemize}

\section{elvisconfig}


\section{RandomSAT}


% TODO
\begin{itemize}
    \item \underline{\textbf{TODO}}
    \item Maybe the permutation script can be used elsewhere (Thorsten seemed 
        interested)
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           RELATED WORK
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\chapter{Related Work}

% TODO
\begin{itemize}
    \item \textbf{\underline{TODO}}
    \item 42 bugs
    \item Variability in ...
    \item Paper from Iago
    \item Fengguang Wu and Intel
\end{itemize}



\newpage
\chapter{Conclusion}
\emph{--- Leave empty until the end---}




\newpage
\bibliographystyle{siam}
\bibliography{bib}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           APPENDIX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Appendices}
\section{Kconfig language}
\section{Data}

\end{document}











% Example of Bibliography
\newpage
\bibliography{bibliography}

% Example of Appendix
\begin{appendices}
\chapter{Code}
\lstinputlisting[language=Python]{../temp.py}
\end{appendices}

% Example of a drawing
\begin{figure}[H]
    \begin{center}
        \begin{tikzpicture}
            \draw rectangle (14,4);
            \draw rectangle (7,2);
            \draw (0,2) rectangle (7,2);
            \draw (7,0) rectangle (8,4);

            \foreach \x in {0,...,6} \draw (\x+7, 0) rectangle (\x+7+1, 2);
            \foreach \x in {0,...,6} \draw (\x+7, 2) rectangle (\x+7+1, 4);
            \foreach \x in {0,...,6} \draw (\x+.5, 4.5) node {$S_\x$};

            \draw (-.5,3) node {$b_0$};
            \draw (-.5,1) node {$b_1$};

            % The overbrace
            \draw (10.5, 4.5) node 
            {$\overbrace{\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad}$};
            \draw (10.5,5.0) node {buckets};

            % Signature matrix (left part)
            \draw (0.5,3.5) node {1};
            \draw (0.5,2.5) node {3};
            \draw (0.5,1.5) node {4};
            \draw (0.5,0.5) node {0};

            \draw (1.5,3.5) node {1};
            \draw (1.5,2.5) node {3};
            \draw (1.5,1.5) node {3};
            \draw (1.5,0.5) node {1};

            \draw (2.5,3.5) node {4};
            \draw (2.5,2.5) node {1};
            \draw (2.5,1.5) node {2};
            \draw (2.5,0.5) node {4};

            \draw (3.5,3.5) node {3};
            \draw (3.5,2.5) node {5};
            \draw (3.5,1.5) node {3};
            \draw (3.5,0.5) node {2};

            \draw (4.5,3.5) node {3};
            \draw (4.5,2.5) node {3};
            \draw (4.5,1.5) node {3};
            \draw (4.5,0.5) node {2};

            \draw (5.5,3.5) node {6};
            \draw (5.5,2.5) node {2};
            \draw (5.5,1.5) node {4};
            \draw (5.5,0.5) node {6};

            \draw (6.5,3.5) node {1};
            \draw (6.5,2.5) node {3};
            \draw (6.5,1.5) node {3};
            \draw (6.5,0.5) node {1};

            % Fill all with red (in right part)
            \foreach \x in {0,...,6} \path[fill=red!30] (7.1+\x,0.1) rectangle 
            (7.9+\x,1.9);
            \foreach \x in {0,...,6} \path[fill=red!30] (7.1+\x,2.1) rectangle 
            (7.9+\x,3.9);

            % Fill the right ones with green
            \path[fill=green!50] (7.1,2.1) rectangle (7.9,3.9);
            \path[fill=green!50] (8.1,0.1) rectangle (8.9,1.9);
            \path[fill=green!50] (10.1,0.1) rectangle (10.9,1.9);

            % Names
            \draw (7.5,3.5) node {$S_0$};
            \draw (7.5,3.0) node {$S_1$};
            \draw (7.5,2.5) node {$S_6$};
            \draw (8.5,3.5) node {$S_2$};
            \draw (9.5,3.5) node {$S_3$};
            \draw (10.5,3.5) node {$S_4$};
            \draw (11.5,3.5) node {$S_5$};

            \draw (7.5,1.5) node {$S_0$};
            \draw (8.5,1.5) node {$S_1$};
            \draw (8.5,1.0) node {$S_6$};
            \draw (9.5,1.5) node {$S_2$};
            \draw (10.5,1.5) node {$S_3$};
            \draw (10.5,1.0) node {$S_4$};
            \draw (11.5,1.5) node {$S_5$};


            % Arrows
            \path[-] (8,-.1) edge [bend left] (6.5,-1);
            \path[->] (6.5,-1) edge [bend right] (5,-2);

            % Candidate squares
            \path[fill=green!50] (3.1, -3.5) rectangle (6.9, -2.2);
            \draw (3,-3.6) rectangle (7,-2.1);

            % Candidate signatures
            \draw (4,-2.5) node {$(S_0, S_1)$};
            \draw (4,-3.0) node {$(S_0, S_6)$};
            \draw (6,-3.0) node {$(S_1, S_6)$};
            \draw (6,-2.5) node {$(S_3, S_4)$};

            \draw (5,-4.0) node {Candidate pairs};
            

        \end{tikzpicture}
    \caption{LSH buckets and bands}
    \label{fig:lsh_buckets}
    \end{center}
\end{figure}


% Example of algorithm
\begin{center}   
    \captionof{algorithm}{Locality Sensitive Hashing algorithm}\label{alg:lsh}
    \begin{algorithmic}
    
    \BState \textbf{Calculate signature matrix as in algorithm 
    \ref{alg:minhashing}}\\

    \State $SIG\gets \text{signature matrix}$
    \State $S\gets \text{number of signatures}$
    \State $bucket\_list\gets \text{empty list}$
    \State $B\gets \text{number of bands}$\\

    \BState \emph{Fill the buckets}
    \For{$b_i$ in $i = 0 \ldots B-1$}
        \State $h_i \gets \text{empty dictionary}$
        \State $bucket\_list.append(h_i)$
        \For{$SIG_j[b_i]$ in $j = 0 \ldots S-1$}
            \State $key \gets SIG_j[b_i]$
            \If{$key$ in $h_i$}
                \State $bucket \gets h_i[key]$
            \Else
                \State $bucket \gets \text{empty list}$
            \EndIf
            \State $bucket.append(j)$
        \EndFor
    \EndFor\\

    \State $candidate\_pairs \gets \text{empty set}$
    \ForAll{$h_i$ in $bucket\_list$}
        \ForAll{$key$ in $h_i$}
            \State $bucket \gets h_i[key]$
            \If{$bucket.length > 1$}
                \For{$pair$ in $bucket$}
                    \State $candidate\_pairs.add(pair)$ 
                \EndFor
            \EndIf
        \EndFor        
    \EndFor\\

    \BState \textbf{Calculate similarities from signature matrix as in 
    algorithm \ref{alg:minhashing}, for the candidate pairs.}

    \end{algorithmic}
\end{center}


% Example of a gnuplot input
\begin{figure}[H]
    \begin{center}
        \input{plots/scurve.tex}
        \caption{S-curve - $f(s) = 1 - (1 - s^r)^b$ ; $k = 1000$}
        \label{fig:scurve}
    \end{center}
\end{figure}


% Example of a table
\begin{figure}[H]
    \begin{center}
        \begin{tabular}{c|c|c}
              & Actual & LSH \\
            \hline
            1 & 1.0 & 1.0 \\
            2 & 1.0  & 1.0 \\
            3 & 0.667 & 0.702 \\
            4 & 0.667 & 0.695 \\
            5 & 0.667 & 0.689 \\
            6 & 0.667 & 0.684 \\
            7 & 0.667 & 0.681 \\
            8 & 0.667 & 0.681 \\
            9 & 0.667 & 0.677 \\
            10 & 0.667 & 0.673 
        \end{tabular}
        \caption{Correctness of LSH}
        \label{tab:lsh-correctness}
    \end{center}
\end{figure}


% Example of equation
\begin{equation}
    \frac{B(64;R,r_1,r_2)}{B(1;R,r_1,r_2} \Rightarrow \frac{64 R}{R + 1 - r_1}
    \label{eq:improvementratio}
\end{equation}


% Example of graphic
\begin{figure}[H]
    \begin{center}
        \includegraphics{plots/bbit/bbit.eps}
        \caption{b-Bit storage improvement}
        \label{fig:bbit}
    \end{center}
\end{figure}
