% === Notes from Elvis ===

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The above line is 80 characters long. Try to keep it under this width.

% There are 3 ways of highlighting:
%  o \texttt
%      o Folders
%      o Files
%      o Program names
%  o \emph
%      o Company names
%      o New concepts that are introduced
%  o \textcode (\texttt with grey background)
%      o Commands
%      o Command output

%\chapter
%    \section
%        \subsection
%            \subsubsection
%            \paragraph

% === Setup ===

% Needed and Layout
\documentclass[a4paper,11pt]{report}
\usepackage[utf8]{inputenc} % utf8 encoding
\usepackage{amsfonts}
\usepackage[T1]{fontenc} % use for allowing < and > in cleartext
\usepackage[margin=2.5cm]{geometry}

% Lists
\usepackage{verbatim}   % useful for program listings
\usepackage{enumitem}
\usepackage[ampersand]{easylist}

% Creating more compact lists
\let\olditemize\itemize
\renewcommand{\itemize}{
    \olditemize
    \setlength{\itemsep}{1pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}
}

% Creating blue citations
%\newcommand{\cit}[1]{
    %\textcolor{blue}{\cite{#1}}
%}


% Creating shortcut for Red Text
\newcommand{\rt}[1]{
    {\color{red}#1}}

% Creating shortcut for Grey Text
\newcommand{\gt}[1]{
    {\color{gray}#1}}

% Trying to create a column tyupe that aligns the dots
\usepackage{dcolumn}
\newcolumntype{d}{D{.}{.}{-1} }


% Creating my own inline code font
\newcommand{\textcode}[1]{
    \fboxsep=1pt
    \texttt{\colorbox{gray!20}{#1}}
}

% Recreating the figure thingy
\newcommand{\figa}{
    \begin{figure}[!htpb]
    \centering
}
\newcommand{\figb}[2]{
    \caption{#1}
    \label{#2}
    \end{figure}
}


% Math
\usepackage{mathtools}   % need for subequations
\usepackage{xfrac}       % Fractions  like 1/4 via \sfrac

% Graphics
\usepackage{graphicx}   % need for figures
\usepackage{color}      % use if color is used in text 
\usepackage[table]{xcolor}     % use for text background color
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{float}

% Other
\usepackage{todonotes}
\usepackage{pdfpages}
\usepackage{subcaption}
\usepackage{latexsym}
\usepackage{fixltx2e}    % use for textsubscript
\usepackage{datetime}    % for the \currenttime
\usepackage[titletoc,title]{appendix}
\usepackage[framemethod=tikz]{mdframed}
\usepackage[titletoc,title]{appendix}
\usepackage{epstopdf}

% Code listing
\usepackage{listings} % For inserting code from file (I think)
\usepackage{algorithm}
\usepackage{algpseudocode}
\renewcommand{\algorithmicforall}{\textbf{for each}}
\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\DeclareCaptionFormat{algor}{%
  \hrulefill\par\offinterlineskip\vskip1pt%
    \textbf{#1#2}#3\offinterlineskip\hrulefill}
\DeclareCaptionStyle{algori}{singlelinecheck=off,format=algor,labelsep=space}
\captionsetup[algorithm]{style=algori}

% Citations and refs
\usepackage{hyperref} % Citations and refs are links
\hypersetup{colorlinks=true,citecolor=blue}
\usepackage{cite}


% URLs 
\usepackage{url}
\usepackage[hypcap=true]{caption}


% for the \lstinputlisting for code blocks
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1.0,1.0,1.0}
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=1pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}
\lstset{style=mystyle}

\begin{document}

% Configuration
\setlength{\parindent}{0cm}
\setlength{\unitlength}{1mm}

% Front Page
\date{September 1st 2015\\ IT University of Copenhagen}
\title{A Quantitative Analysis of Warnings in Linux \\ Draft: 
    \today~\currenttime}
\author{Elvis Flesborg\\
\texttt{efle@itu.dk}}
\clearpage\maketitle
\thispagestyle{empty}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           TABLE OF CONTENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\thispagestyle{empty}



\newpage

\setcounter{page}{1}


\begin{abstract}
    \emph{---Leave blank until the end---}

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           INTRODUCTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
Software projects with high variability rate can be configured to suit many
needs with the same code base.

Possibly the largest open source code base which adapts the variability paradigm
is the Linux kernel. It contains approximately 10,000 different configuration 
options.
\\

The ground for this paper is somehow based on the paper \emph{42 Variability 
Bugs in the Linux Kernel: A Qualitative Analysis}
    \cite{42bugs}
, where bugs are qualitatively analyzed, not quantitatively. In this report, 
warnings will be used as a proxy for errors, and will be analysed 
quantitatively.
\\

The following contributions will be made. Analysis of distributions of
warnings in the Linux kernel, comparisson of warning distribution in a stable
version of the Linux kernel and an unstable version. Also an analysis of which
subsystems contain the most warnings.

% TODO
\iffalse
 v  Large amount of variability
 .  Software Product Lines
 v  Linux Kernel
 v  42 bugs paper
 .  During development (stable vs unstable)
 v  Following contributions:
     v  distribution of warnings in Linux
     v  difference in stable and unstable
     v  distribution of subsystems
 .  Research Questions
\fi




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           BACKGROUND
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
        \chapter{Background}

A \emph{Linux} operating system is often referring to a \emph{GNU/Linux} 
operating system, where the Linux part of \emph{GNU/Linux} is the Linux kernel, 
and the \emph{GNU} part is a software bundle with utilities (eg. a shell, a 
compiler, etc...) \cite{gnupack}. Both is 
needed, to have a working operating system. 

This report will only focus on the \emph{Linux kernel}, and not the \emph{GNU} 
bundle.


        \section{The Linux Kernel}
The Linux kernel is written in by many thousand of people all over 
the world, and has been ported to more than 20 architectures, which makes it 
very scalable\footnote
    {See the \textbf{README} file in the Linux kernel tree}.

It was first developed in 1991 by \emph{Linus Torvalds}, and has since been 
growing. Today the code base is 19 million lines of code\footnote
    {\textcode{grep -r '.*' * | wc} in the kernel root folder}.


        \section{Variability}
Many software products are configurable in some way. This creates the 
possibility of tailoring the software to suit different needs. For example 
different kinds of hardware, or different functionalities. 
\\

This is called \emph{variability} in software and a software product of 
this type is called \emph{Software Product Lines} (SPL). When different 
software programs can be derived from the same source code base. 

Before compilation, the source code will have to be configured, at a 
preprocessing step, which will choose (either automatically, or the user will 
choose) which parts of the code should be included, by enabling or disabling a 
set of \emph{features}. 

The code in its entirety is not a valid program.
    \cite[p. 1]{IntDatSPL}
\\



Software with a high-degree of variability is usually refered to as 
\emph{Variability-Intensive Systems} or \emph{VISs}. Linux is a \emph{VIS} with 
more than 10,000 different features. Other examples of 
\emph{VISs} are \emph{Eclipse}, \emph{Amazon Elastic Compute Service}, and 
\emph{Drupal Content Management Framework}\cite
    [p. 1]{VarTesDrupal} to name a few.
\\

The Linux kernel is very configurable. In the configuration files (the Kconfig 
files), there is a total of 14,387 different features, that can be configured.
    \footnote {14,387 across all architectures, with an average of 9,984 per 
        architecture, and 10,335 for the \texttt{x86} architecture}
It is the open source software product with the highest degree of variability.

This high degree of variability has also had an impact on the use cases for the 
Linux kernel. Linux is used for anything from small embedded devices (like car 
GPSs, and cell phones) to supercomputers.
In fact 98\% of the top 500 supercomputers in the world run a Linux distibution
    \cite{top500}
.
\\

This high variability rate makes maintaining the code somewhat harder to 
grasp, and this makes the code base more error prone. So what you get in 
scalability you pay for in complexity of maintaining the code. 
    \footnote{Refer to Jean's project maybe}
    \footnote{Also refer to a paper that andrzej made about industrial 
        something. It said something about how much more efficient the code was,
        when variability was there.}


        \section{Linux Kernel Development}

\begin{center}
    \emph{
        Comment from the Linux team or something...
    }
\end{center}


        \subsection*{Stable and Mainline tree}

The Linux kernel development cycle has approximately 2$\sfrac{3}{4}$ months 
from one stable release to the next stable release
    \cite{crystalball}
.
In the meantime, \emph{Release Candidates (RCs)}, are released approximately 
once every week.

Then, when the top maintainers of the mainline tree think that the kernel is 
stable enough, a new stable version is created, and the whole process is 
repeated.


        \subsection*{linux-next tree}

Then there is the \emph{linux-next} tree. It is a \emph{git} repository, which 
merges over 200 other \emph{git} repositories
    \cite{nextTrees}
, which 
are all based on the \emph{mainline} tree. The \emph{linux-next} tree is 
merging these other trees every day and the merge conflicts are handled. 
Therefore the \emph{linux-next} tree always contain the newest commits. 

\textcolor{gray}{
This tree will get some bugs fixed sooner than if everyone contributed to the 
mainline and tested on that. Comparing to a stable version, one would suspect 
the \emph{linux-next} tree to have more bugs, since it has not been tested, 
and it is the newest code available, which means more bugs have been inserted.
}

For this thesis project, both the \emph{linux-next} tree and the latest stable 
version is used. As time of data gathering, the latest stable version is 
\emph{4.1.1}.

    \footnote{[Y] http://neuling.org/linux-next-size.html}
    \footnote{http://news.gmane.org/gmane.linux.kernel.next - the linux-next 
        mailing list archive}
    \footnote{[Z] http://kisskb.ellerman.id.au/kisskb/matrix/A}


        \section{Inner Workings of Linux Kernel}

This section will explain in coarse detail, the structure of the Linux kernel.
From the directory structure, over configuration, to compilation of the kernel.


        \subsection{Subsystems}

The directories in the root folder of the Linux kernel source code are called 
\emph{subsystems}. 

% --- Not showing this graph ---
% \figa
%     \includegraphics{plots/subsystemsizes.eps}
% \figb{Visualization of the sizes of the subsystems}{fig:subsystems}
% ---

The \texttt{drivers/} subsystem is by far the largest subsystem. It contains 
all hardware drivers. It is also mostly contributed to by hardware vendors.
    \footnote{Source? and is it true? -What would Greg Kroah Hartman say?}
Since it is the largest subsystem, one could suspect it to contain the most 
errors. And even when taking relative size into account, one could suspect this
on the grounds of the majority of the code being written by hardware vendors.
\\

The \texttt{arch/} subsystem contains architecture specific source code. 
There are 29 architectures in the \texttt{arch/} folder, which is why Linux is 
the operating system, which supports the most architectures in the world.
    \cite{22thbirthday}
.
\\

The \texttt{mm/} subsystem is for memory management, \texttt{security} is 
libraries regarding security, and \texttt{kernel} is the where the kernel 
specific code is. Other subsystems are \texttt{sound/}, \texttt{net/}, and 
\texttt{lib/}

% --- Not showing this graph ---
% \figa
%     \includegraphics{plots/archsizes.eps}
% \figb{The sizes of the different architecture diretories}{fig:archsizes}
% ---


% TODO
\iffalse
  . talk about allnoconfig alldefconfig in background chapter
  v mention exactly how many configurations there are. (maybe the report 
    from Andrzej). like 2**11,000
  . Find out how to find the exact number of possible configurations. It 
    is in some article, I got by Andrzej. Plus maybe SharpSAT.
  . Write about all the subsystems and what they are for.
  . Explain how to find the number of features by grepping.
  . Maybe talk about the percentage of code in every subsystems. What is 
    Linux kernel made of?
  . talk about who contributes to the kernel. (intel, novell). Both in 
    code and money?
  . mention some more subsystems other than drivers and arch
\fi


        \subsection{Feature Models}

A feature model is a way of representing all the possible configurations - 
\emph{the configuration space}. It contains all the features with their 
respective options and all the constraints and dependencies.

A visualization of a feature model is called a feature diagram, there is an 
example in Figure \ref{featurediagramphone}. The example 
will be tiny compared to that of the Linux kernel. The feature model of the 
Linux kernel is too big to fit in a normal sized report.

In Figure \ref{featurediagramphone} there is a toy example of a feature 
diagram. It depicts a feature model of a phone configuration, where there are 
some mandatory features (\textbf{Screen} and \textbf{Calls}) and some optional 
(\textbf{Media} and \textbf{GPS}), 
and also a choice option (\textbf{Color}, \textbf{BW}, and \textbf{High 
Definition}) for the screen type, where only one of them may be enabled. A 
cross-tree dependency is also present, which states that \textbf{Media} with 
all of its children can only be enabled if a \textbf{High Definition} screen is 
enabled.

There is no consensus on a unified notation for attributes in feature models
    \cite{AAFM}


% The feature diagram
% 80 lines down to \figb
\figa
    \begin{tikzpicture}
        % The top box
        \draw (3,3) rectangle (5,3.6);
        \draw (4,3.3) node {Mobile};

        % Middle words
        \draw (0.00,1.75) node {Calls};
        \draw (3,1.75) node {Screen};
        \draw (6,1.75) node {Media};
        \draw (9,1.75) node {GPS};

        % Middle edges
        \draw (0,2.1) edge (4,3);
        \draw (3,2.1) edge (4,3);
        \draw (6,2.1) edge (4,3);
        \draw (9,2.1) edge (4,3);

        % Middle dots
        \draw[fill=black] (0,2.1) circle (0.1);
        \draw[fill=black] (3,2.1) circle (0.1);
        \draw[fill=white] (6,2.1) circle (0.1);
        \draw[fill=white] (9,2.1) circle (0.1);

        % Middle boxes
        \draw (-1,1.5) rectangle (1,2);
        \draw (2,1.5) rectangle (4,2);
        \draw (5,1.5) rectangle (7,2);
        \draw (8,1.5) rectangle (10,2);

        % Bottom words
        \draw (0,-0.25) node {Color};
        \draw (1.5,-0.25) node {BW};
        \draw (4,-0.25) node {High Definition};
        \draw (7,-0.25) node {Camera};
        \draw (9,-0.25) node {MP3};

        % Bottom edges
        \draw (0,0.1) edge (3,1.5);
        \draw (1.5,0.1) edge (3,1.5);
        \draw (4,0.1) edge (3,1.5);
        \draw (7,0.1) edge (6,1.5);
        \draw (9,0.1) edge (6,1.5);

        % Bottom dots
        %\draw[fill=white] (0,0.1) circle (0.1);
        %\draw[fill=white] (2,0.1) circle (0.1);
        %\draw[fill=white] (4,0.1) circle (0.1);
        \draw[fill=white] (7,0.1) circle (0.1);
        \draw[fill=white] (9,0.1) circle (0.1);

        % The 'or'
        \draw (1.5,0.8) edge [bend right] (3.5,0.8);

        % Bottom boxes
        \draw (-1,-0.5) rectangle (0.8,0);
        \draw (1.1,-0.5) rectangle (1.9,0);
        \draw (2.5,-0.5) rectangle (5.5,0);
        \draw (6,-0.5) rectangle (7.9,0);
        \draw (8.4,-0.5) rectangle (9.6,0);


        % The legend
        \draw[fill=black] (4,-1.5) circle (0.1);
        \draw[fill=white] (4,-2) circle (0.1);
        \draw[right] (4.2,-1.5) node {Mandatory feature};
        \draw[right] (4.2,-2) node {Optional feature};

        \draw (4.0,-2.3) edge (4.2,-2.7);
        \draw (4.0,-2.3) edge (3.8,-2.7);
        \draw (4.1,-2.55) edge [bend left] (3.9,-2.55);
        \draw[right] (4.2,-2.5) node {Choice};

        % The cross-tree dependency
        \draw[right] (-3, -2) node {\textbf{Media} depends on 
            \textbf{High Definition}};

    \end{tikzpicture}
\figb{An example of a feature diagram of a phone}{featurediagramphone}
% 80 lines up to \figa


            \paragraph{The Kconfig language} 
is the language of the feature model in Linux (also used for other projects 
like BusyBox, BuildRoot, CoreBoot, Freetz and others)
    \cite[p. 4]{VarModSSD}
.
The configuration files have the prefix \textcode{Kconfig}, and are 
scattered all over the Linux kernel source code tree, where they include each 
other. There are 1195 Kconfig files in total in the Linux kernel
    \footnote{Found with the command \textcode{find . | grep Kconfig | wc}}
with 956 of them relevant for the \texttt{x86/} architecture.
\\

When a configuration is created, it is saved to a file called \texttt{.config}.
In this file, all features are prefixed with \textcode{CONFIG\_}.

The different data types and the percentage of them in the \texttt{x86} 
architecture are \textcode{boolean} (35\%), \textcode{tristate} 
(61\%), \textcode{string} (0.41\%), \textcode{hex} (0.32\%), and 
\textcode{integer} (3.7\%). For a description of 
the context free grammar of the Kconfig language, see the appendices.
    \footnote{Write the Backus Naur Form of Kconfig in the Appendix}
\\

\figa
    \lstinputlisting[]{code/kconfigphone}
\figb{Kconfig for the phone example}{kconfigphone}

        {\color{gray}
The features in Kconfig can be split into four different types, \emph{User 
features}, \emph{Implementation features}, \emph{Derived features}, and 
\emph{Capability features}
    \cite[p. 8]{VarModSSD}
.
\\ 

\paragraph{User} features are features that the user chooses a value for in the 
configurator. In other words, a feature, that has a prompt option in the 
Kconfig language. 

These features may not directly inflict the compiler's choices, but may only 
open up for other features in the configurator.

\paragraph{Implementation} features are referenced in the source code, and will 
directly influence what code the preprocessor will select for compilation.

\paragraph{Derived} features are invisible to the user, and are set by other 
features using the \textcode{select FOO} syntax.

\paragraph{Capability} features in Linux are features, that simulate a reverse 
dependency. These features are also not randomly chosen by 
    \texttt{randconfig}
        \footnote{Should I give an example here of the capability one?}
    . Their names often start with \textcode{CONFIG\_HAVE\_} or 
    \textcode{CONFIG\_ARCH\_HAVE\_}, and only have \emph{type} option set (often to 
    \texttt{bool}).
            } % color gray

        \footnote{describe that all models are typically wide and shallow, 
        VarModSSD page 19}
        \footnote{write how Kconfig is a beast sometimes. Child nodes exclusding 
        their parents}
        \footnote{How many are there of each of these. distirbution.}


%TODO
\iffalse
  . Explain the Kconfig language a bit
  . Reference to Thorsten's projects
  . Refer to the /Documentation/kbuild/kconfig-language.txt
  . Should I have the Backus Naur Form of the Kconfig language here?
\fi

        \subsection{Configuring of Linux}

The Linux kernel comes with different ways of creating your own configuration 
file. There is a question based one: \texttt{config}, and some menu based ones:
\texttt{menuconfig}, \texttt{xconfig}, \texttt{nconfig}, \texttt{gconfig}, 
but also some that will never prompt the user for anything, but create an 
automated config: \texttt{allyesconfig} (enabling as much as possible), 
\texttt{allnoconfig} (disabling as much as possible), \texttt{defconfig} 
(choosing the default values for everything), and \texttt{randconfig} (choosing 
random values for everything).
\\

See figure \ref{fig:lineofconfigs} for a few examples of what the graphical 
configuration tools look like.
\\


\figa
    \includegraphics[scale=0.25]{pngs/configs50percent.png}
\figb{gconfig, menuconfig, nconfig, and xconfig}{fig:lineofconfigs}


%TODO
/iffalse
  . 
/fi


\subsection{Experimental Setup}

The compilation is done mainly by \emph{GCC - The GNU Compiler Collection}
    \footnote{\url{https://gcc.gnu.org}}.

During compilation, \texttt{GCC} will output warnings when there are any
    \footnote{There are on average 12 warning messages per compilation}
.

In a warning, there is information about a possible coding mistake that might 
break the code. There are about 30 different warning types that are enabled by 
default \cite{gccwarnings} Some of them are more severe than others.

The warnings have the output format \textcode{[-Wwarningtype]}, and this is 
output whenever there is a warning. This makes the warnings very easy to 
quantify automatically.
\\

If an error occurs during compilation, \texttt{GCC} will stop, and give an error
message. The error messages though, are not as fulfilling as the warning 
messages. Often an erroneous subprocess will return an errorcode to 
\texttt{GCC}, which will then stop. 

All that is shown is the errorcode, and the directory in which it occured.

    \footnote{example of an error message}
\\

An error need not be a bug in the Linux kernel code. It can be a missing program
on the machine that is compiling the code (the \emph{host machine}). These will
be called \emph{host errors}.
\\




        \subsection{GCC Warnings}
Here follows a list of the warnings that was found during the compilations. 
They are ordered alphabetically.


            \paragraph{array-bounds}
is given, when GCC is certain that a subscript to an array is always out of 
bounds.

% See example in figure \ref{lst:arraybounds}.

% \figa
    % \lstinputlisting[language=C]{code/arraybounds}
% \figb{}{lst:arraybounds}


            \paragraph{cpp}
will show \textcode{\#warning} directives written in the code. This is a warning
message that the coder can pass to the compiler. Often they will not result in 
an error.


            \paragraph{deprecated-declarations}
will show warnings when functions, variables, or types have been declared 
deprecated be a programmer.


            \paragraph{discarded-array-qualifiers}
            \paragraph{error=}
is a prefix, which means that the warning will cause an error. Sometimes 
developers do not want a specific warning to happen without the compilation 
stopping. Then they can enable this flag in the makefile.

There is also a \texttt{no-error=}, which nullifies the \texttt{error=} flag.


            \paragraph{frame-larger-than=}
            \paragraph{implicit-function-declaration}
            \paragraph{incompatible-pointer-types}
            \paragraph{int-conversion}
            \paragraph{int-to-pointer-cast}
\emph{See the section about pointer-to-int on page \pageref{par:pointertoint}}

            \paragraph{logical-not-parentheses}
occurs when the left hand side of an expression contains a \emph{logical not} 
(a \texttt{!} in C). An example is \textcode{if (!ret == template[i].fail)}
    \footnote{From the file \texttt{crypto/testmgr.c}}
.

The warning refers to the \textcode{!ret}, which should have been inside 
parentheses to be correct, like so \textcode{(!ret)}.


            \paragraph{maybe-uninitialized}
is when there is an uncertainty about a variable being uninitialized. In the 
case in figure \ref{lst:maybeuninitializedreal} there is a 
\texttt{switch-case} where \texttt{sgn} is not initialized in all of the cases.

If \emph{GCC} cannot see for sure that the variable is initialized, 
even if it would have been initialized in all of the cases, it will return this 
warning.

\figa
    \lstinputlisting[language=C]{code/maybeuninitializedreal}
\figb{A real example of maybe-uninitialized function}{lst:maybeuninitializedreal}


            \paragraph{overflow}


            \paragraph{pointer-to-int-cast}
            \label{par:pointertoint}
This warning would normally be sign of bad code. It is usually when a pointer 
is cast to a \texttt{long} and then later cast back into a function call. This 
is widely spread in Linux to simulate the effects of \emph{Object Oriented 
Programming}.
    \footnote{source: Claus... find other source.}


            \paragraph{return-type}
            \paragraph{switch-bool}
            \paragraph{uninitialized}
            \paragraph{unused-function}
is a warning about a function that has never been called. This represents dead 
code, or code pollution. 

In the example in figure \ref{lst:unusedfuncreal}, the function 
\texttt{bq27x00\_powersupply\_unregister} will not be called if the feature 
\texttt{CONFIG\_BATTERY\_BQ27X00\_I2C} is not enabled, and is therefore an 
unused function.

\figa
    \lstinputlisting[language=C]{code/unusedfuncreal}
\figb{A real example of unused function - from the file 
    \texttt{drivers/power/bq27x00\_battery.c}}{lst:unusedfuncreal}


            \paragraph{unused-variable}
is basically the same as \texttt{unused-function}, but only with a variable 
instead of a function. There will be no example of this.


            \paragraph{unused-label}


%TODO
/iffalse
 .  declare each warning either dangerous or not-dangerous.
/fi


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           METHODOLOGY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\chapter{Methodology}

\emph{Objective:}
The objective is to make a quantitative analysis of warnings in randomly 
generated Linux kernels. The warnings functions as a proxy of errors.
These are the research questions:
\\

\textbf{RQ1:} Will the unstable linux-next repository generate more warnings 
than the stable kernel.
\\

\textbf{RQ2:} In what subsystems do the most errors occur?
\\

\textbf{RQ3:} What warnings are the most common.
\\

\textbf{RQ4:} Is there any significant difference in the warnings in the 
stable versus the unstable.
\\

\textbf{RQ5:} Are there any specific features, that when enabled, will produce 
more warnings than others. 
\\


\emph{Subject:}
There will be generated random configurations, and these will be used to 
compile two different versions of the Linux kernel, a stable Linux kernel 
version \emph{4.1.1}, and a Linux kernel from the \emph{linux-next} repository
    \footnote{Can both be found on \url{https://www.kernel.org}}.
\\

\emph{Methodology:}
The methodology will be in four parts. First part is finding a way of
generating random configurations. Second part is compiling the Linux kernel 
using these configurations while obtaining information about the compilation.
Third part is analyzing the data.



\section{Generating random configurations}
The configurator \texttt{randconfig} is used in this project. It is used as a 
proxy for totally representative configurations. The truth is that 
\texttt{randconfig} is not representative, but is biased towards features 
higher up in the feature model tree.
\\

See figure ~\ref{randconfigtoy} for a toy example of a Kconfig feature model. 
It is a very small example with only two features, but it will easily explain 
some limitations of using \texttt{randconfig}.

\figa
    \lstinputlisting[language=C, firstline=1, morekeywords={prompt, config, 
        depends, on, bool, endchoice, choice,{||}}]{code/kconfigrandconfigtoy}
\figb{A toy Kconfig feature model}{randconfigtoy}

% --- 33 lines down ---
\figa
    \begin{tikzpicture}
        % Names of configs
        \draw (2,4) node {\textcode{CONFIG\_A}};
        \draw (4,2) node {\textcode{CONFIG\_B}};

        % yeses and nos
        \draw (1,3) node {\textcode{=n}};
        \draw (3,3) node {\textcode{=y}};
        \draw (3,1) node {\textcode{=n}};
        \draw (5,1) node {\textcode{=y}};

        % lines not necessarily from above and down
        \draw[-] (1.9,3.8) edge (1,3.2);
        \draw[-] (2.1,3.8) edge (3,3.2);
        \draw[-] (3,2.8) edge (4,2.2);
        \draw[-] (3,1.2) edge (4,1.8);
        \draw[-] (5,1.2) edge (4,1.8);

        % Draw percentages
        \draw (1,3.5) node {\tiny{50\%}};
        \draw (3,3.5) node {\tiny{50\%}};
        \draw (3,1.5) node {\tiny{50\%}};
        \draw (5,1.5) node {\tiny{50\%}};

        \draw (1,2.5) node {\textbf{\underline{50\%}}};
        \draw (3,0.5) node {\textbf{\underline{25\%}}};
        \draw (5,0.5) node {\textbf{\underline{25\%}}};

        %%%% ==== The next graph ====

        % Names of configs
        \draw (9,4) node {\textcode{CONFIG\_A}};
        \draw (11,2) node {\textcode{CONFIG\_B}};

        % yeses and nos
        \draw (8,3) node {\textcode{=n}};
        \draw (10,3) node {\textcode{=y}};
        \draw (10,1) node {\textcode{=n}};
        \draw (12,1) node {\textcode{=y}};

        % lines not necessarily from above and down
        \draw[-] (8.9,3.8) edge (8,3.2);
        \draw[-] (9.1,3.8) edge (10,3.2);
        \draw[-] (10,2.8) edge (11,2.2);
        \draw[-] (10,1.2) edge (11,1.8);
        \draw[-] (12,1.2) edge (11,1.8);

        % Draw percentages
        \draw (8,3.5) node {\tiny{33\%}};
        \draw (10,3.5) node {\tiny{66\%}};
        \draw (10,1.5) node {\tiny{50\%}};
        \draw (12,1.5) node {\tiny{50\%}};

        \draw (8,2.5) node {\textbf{\underline{33\%}}};
        \draw (10,0.5) node {\textbf{\underline{33\%}}};
        \draw (12,0.5) node {\textbf{\underline{33\%}}};
    \end{tikzpicture}
\figb{(left) How \texttt{randconfig} will select (right) Representative 
    selection}{randconfigtoy50}
% --- 33 lines up ---

The example in figure ~\ref{randconfigtoy50}(left) shows that the three possible
configurations (\texttt{\{\}}, \texttt{\{A\}}, and \texttt{\{A,B\}}) do 
not have the same chance of getting created by \texttt{randconfig}.

For the creation to be representative, all the three possible configurations 
should have equal chance of being created (33\%). See figure 
~\ref{randconfigtoy50}(right) for a visualization of how the selection should 
be to be representative.


Representativeness does not matter for the Linux kernel developers, the 
\texttt{randconfig} function is merely used as a simple fuzz testing tool
    \footnote{source}
.

This ultimately means that \texttt{randconfig} is not representative in its 
configuration creation. more about representativeness in the section 
\ref{rephunt}.
\\

Even though \texttt{randconfig} generates valid configurations, there were still
some features that showed to be creating bogus errors.
\\

For instance, there is a feature in the feature model that is called 
\textcode{CONFIG\_KERNEL\_LZO}, which enables kernel compression with the 
\emph{LZO library}.

If the \emph{LZO library} is not installed on the host machine, then the 
compilation will fail.
\\

There exist many other examples like this in the Linux kernel where an 
uninstalled program will result in an unbuilt kernel. These \emph{host 
errors} would have to be minimized, since they are not actual kernel errors, 
but local errors. 

On the build system for this project, the \emph{lzo} package was in the Linux 
distribution's repository, and therefore easy to install. The \emph{lz4} 
package however was not.
    \footnote{be sure of that the warnings are ONLY for the linux kernel and
        not \emph{host warnings}}
\\

The following is a list of mandatory features, which are added to decrease the 
amount of host errors. In an early period of the project, it was found out that 
these specific features with specific values would stop the compilation every 
time.

It decreases the configuration space of this project, but otherwise 
would just give a lot of false positives.
\\

All these lines are added to the configurations, which are generated in
this project.

\begin{itemize}
    \item \textcode{CONFIG\_STANDALONE=y}
    \item \textcode{CONFIG\_FW\_LOADER=n}
    \item \textcode{CONFIG\_SECCOMP=y}
    \item \textcode{CONFIG\_PREVENT\_FIRMWARE\_BUILD=y}
    \item \textcode{CONFIG\_*LZ4*=n}
        \footnote{This means that all features having to do with \emph{lz4} 
                    were disabled}
\end{itemize}

See chapter~\ref{ch:ttv} about Threats to Validity on page \pageref{ch:ttv} 
for a more thorough description of the specific features.


    \subsection{The Hunt for Representativeness}
    \label{rephunt}
To make the sample of configurations representative, three different ways are
proposed, and researched if feasible. They are \emph{changing randconfig}, 
\emph{permuting Kconfig}, and \emph{generate and filter}.
\\

To change \texttt{randconfig} to be representative, one will have to make 
it aware of the whole dependency tree before randomly selecting features. This 
seems infeasible since the configuration space is so large. It will not fit 
in memory. 
\\

The next proposal is to \emph{permute the Kconfig} files. First by desugaring 
the Kconfig files to be in one \emph{level} only
    \footnote{For example by replacing \textcode{if FOO} clauses by 
    \textcode{depends on} options in the features clauses.}
, and then randomly scramble the feature 
clauses in the files. If the \texttt{randconfig} script then loads the Kconfig
files from the top to the bottom, it will 'flip the coin' starting a random 
place each time.

This will not work, as \texttt{randconfig} does not flip the coin when reading 
the Kconfig files. Rather, it reads the Kconfig files, and then 'flips the 
coin' on the dependency tree.
\\

The last way of generating a representative sample of configurations is a 
method which is dubbed \emph{generate and filter}. 

\texttt{.config} files are generated, and the invalid ones are 
filtered away. 
\\

In the generation process, some mandatory features are given fixed values
    \footnote{These are, among few others, features from the 
    \texttt{allnoconfig}}
. All other values are randomly generated.

Unfortunately this method never did find a valid configuration even after 
generating 100,000 configurations.
\\

Since none of the three proposed methods works, \texttt{randconfig} has become 
the preferable choice.


\section{Compiling and Collecting Data}
When a configuration has been created, the Linux kernel is compiled using 
that configuration file by running the command \textcode{make all}. This 
command runs \emph{GNU Make}, which is instructed how to compile the kernel with
\emph{GCC - The GNU Compiler Collection}.

\emph{GCC} will output warnings and error messages, which is saved for analysis.
\\

The compilations has mainly been done on a computer at the IT University 
of Copenhagen. The computer has $32\times2.8 MHz$ and $128 GB$ of RAM, and the 
average time to compile a kernel and upload the data was around 1 minute and 35 
seconds. A fairly regular laptop with 4 cores and 8 GB of RAM does that in just 
over 8 minutes on average. 
\\


\iffalse % fi 51 lines down
    \paragraph{The relevant warnings}
are warnings that may cause an error at some point. The \emph{uninitialized 
variable} warning is such a warning. If a variable is uninitialized, and ends 
up being called, it may cause an error, and stop the compilation. See figure 
\ref{lst:uninitvar} for a code example.

The relevant warnings are:

\begin{itemize}
    \item Uninitialized variable
    \item Maybe uninitialized
    \item Overflow
    \item Deprecated declarations
        \footnote{Complete this list}
\end{itemize}

\figa
    \lstinputlisting[language=C, firstline=3]{code/uninitvar.c}
\figb{A toy program showing an uninitialized variable.}{lst:uninitvar}

If \textcode{CONFIG\_A} is not enabled in the program in figure 
~\ref{lst:uninitvar} it will return the warning 
'\texttt{'n' is used uninitialized in this function [-Wuninitialized]}' and the 
output, when the program is run, will be '\texttt{0Hello world}',
which is wrong, as the program was meant to output '\texttt{Hello World}'.

    \paragraph{The irrelevant warnings}
are warnings that will not stop the compilation, and will not make the program 
output wrong things. Warnings like \emph{unused function}, \emph{unused 
variable}, \emph{unused label}, and \emph{unused value}, will all end up as 
dead code, which is bad for fitting a kernel on some hardware with limited 
space. Apart from that it is nothing else than code pollution. See figure 
~\ref{lst:unusedvar} for a code example  of an unused variable.

The irrelevant warnings are:

\begin{itemize}
    \item Unused function
    \item Unused variable
    \item Unused label
    \item Unused value
        \footnote{Complete this list}
\end{itemize}

\figa
    \lstinputlisting[language=C, firstline=3]{code/unusedvar.c}
\figb{A program resulting in an unused variable warning.}{lst:unusedvar}

This will return the warning '\texttt{unused variable 'n' [-Wunused-variable]}'.

\fi % iffalse 51 lines up


Every time a compilation is running, \emph{GCC} will output warning and error 
messages in the \emph{standard error} output. This output is then scraped 
through for categorization.

An output line will contain a \emph{bug type}, a \emph{filename}, \emph{line 
number}, and a \emph{message} describing the warning in english.
\\

When a compilation is done, the output is scraped and categorized, and then 
uploaded to a database, for easy querying during and after the project. 

See the figures ~\ref{fig:conftable}, ~\ref{fig:bugstable}, and 
~\ref{fig:filestable} for the database tables.
\\

% 55 lines down
\figa
    \begin{tabular}{c|c|c}
        \hline 
        \hline
        \multicolumn{3}{c}{\textbf{Configurations}} \\
        \hline
        \textbf{Name} & \textbf{Type} &\textbf{primary key} \\
        \hline
        hash & char(64) & primary key \\
        exit\_status & int(1) \\
        conf\_errs & text \\
        linux\_version & varchar(100) & primary key \\
        original & longtext \\
        \hline
        \hline
    \end{tabular}
\figb{The Configurations table}{fig:conftable}

\figa
    \begin{tabular}{c|c|c}
        \hline
        \hline
        \multicolumn{3}{c}{\textbf{Bugs}} \\
        \hline
        \textbf{Name} & \textbf{Type} &\textbf{primary key} \\
        \hline
        hash & char(64) & primary key \\
        type & varchar(50) \\
        linux\_version & varchar(100) \\
        config\_hash & char(64) \\
        subsystem & varchar(30) \\
        original & longtext \\
        \hline
        \hline
    \end{tabular}
\figb{The Bugs table referring to the Configurations table}{fig:bugstable}

\figa
    \begin{tabular}{c|c|c}
        \hline
        \hline
        \multicolumn{3}{c}{\textbf{Files}} \\
        \hline
        \textbf{Name} & \textbf{Type} &\textbf{primary key} \\
        \hline
        id & int(11) & primary key \\
        path & varchar(50) \\
        line & varchar(15) \\
        bug\_id & char(64) \\
        \hline
        \hline
    \end{tabular}
\figb{The Files table referring to the Bugs table}{fig:filestable}

% first figa 55 lines up


\section{Analyzing Data}
This report is a quantitative analysis in comparisson to 
    \cite{42bugs}
, which is a qualitative analysis of bugs in Linux.

In this paper, warnings are analysed, not errors, seeing as the format of the 
error messages prohibits to automatically make sense of categorization.



\section{Original Objective}
The original objective of this report was to categorize errors and not 
warnings, and make a quantitative analysis on those. The majority of the error
messages do not have an error type classified, but just a filename, and a 
message.
\\






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               RESULTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\chapter{Results}

A total of 42,060 configurations were compiled. Half of them from the unstable 
Linux version, and the other half a stable version of Linux.

    \subsection{Stable}
In table \ref{stablewarndis} is shown the distribution of warnings in the 
stable Linux kernel. The warnings that will cause code pollution are typed in 
grey and the more severe ones, that might cause a compilation error is typed 
in black.

17\% of the compilations stopped with an error. These errors were often host 
errors, and will not be looked into. The compilations that had errors were made 
to stop after the first error was found to not have data pollution caused by an 
avalanche effect.

\figa
    \begin{tabular}{r|d}
        \hline
        \hline
        \textbf{Warning} & \multicolumn{1}{c}{\textbf{Percentage}} \\
        \hline

            \rowcolor[gray]{0.8}
        {unused-function} & 59. \% \\
        maybe-uninitialized & 45. \% \\
        logical-not-parentheses & 30. \% \\
            \rowcolor[gray]{0.8}
        unused-variable & 29. \% \\
        cpp & 24. \% \\
        uninitialized & 19. \% \\
            \rowcolor{red}
        {ERROR} & 17. \%  \\
        pointer-to-int-cast & 17.\% \\
        discarded-array-qualifiers & 17.\% \\
        switch-bool & 15.\% \\
        frame-larger-than= & 14.\% \\
        array-bounds & 11.  \% \\
        return-type & 7.7 \% \\
        int-to-pointer-cast & 7.6 \% \\
        overflow & 6.5 \% \\
            \rowcolor[gray]{0.8}
        unused-label & 5.4 \% \\
        deprecated-declarations & 5.4 \% \\
            \rowcolor[gray]{0.8}
        error=implicit-function-declaration & 4.6 \% \\
        int-conversion & 2.7 \% \\
        implicit-function-declaration & 1.0 \% \\
        incompatible-pointer-types & 0.74 \% \\
            \rowcolor[gray]{0.8}
        error=implicit-int & 0.029 \% \\

        \hline
        \hline
    \end{tabular}
\figb{Distribution of warnings in the stable kernel}{stablewarndis}


    \subsection{Subsystems With Errors}
Every warning with a subsystem is distributed as in figure \ref{stablessdis}. 
Many warnings contain multiple subsystems, so the percentages will not equal 
100\%.

\figa
    %\begin{tabular}{r|r@{.}l}
    \begin{tabular}{r|d}
        \hline
        \hline
        \textbf{Subsystem} & \multicolumn{1}{c}{\textbf{Percentage}} \\
        \hline
        
        drivers/ &  93. \%  \\
        include/ &  55. \%  \\
        fs/ &  35. \%  \\ % Same exact number as arch/
        arch/ &  35. \%  \\ % Same exact number as fs/
        arch/x86/ &  35. \%  \\ % Same exact number as fs/ and arch/
        kernel/ &  24. \%  \\
        net/ &  18. \%  \\
        crypto/ &  17. \%  \\
        sound/ &  16. \%  \\
        mm/ &  14. \%  \\
            \rowcolor[gray]{0.8} 
        {usr/} &  12. \%  \\ % Same exact number as samples/
            \rowcolor[gray]{0.8} 
        {samples/} &  12. \%  \\ % Same exact number as usr/
        lib/ &  11. \%  \\
        block/ &  8.5  \% \\
            \rowcolor[gray]{0.8} 
        {scripts/} &  1.8 \% \\
        security/ &  0.091 \% \\
            \rowcolor[gray]{0.8} 
        {ipc/} &  0.0048 \% \\
            \rowcolor[gray]{0.8} 
        {init/} &  0.0048 \% \\
            \rowcolor[gray]{0.8} 
        {tools/} &  0.0048 \% \\
            \rowcolor[gray]{0.8} 
        {virt/} &  0.0 \% \\

        \hline
        \hline
    \end{tabular}
\figb{Distribution of all subsystems with warnings}{stablessdis}



\figa
    \begin{tabular}{c|c|c|c}
        \hline
        \hline
        ss     & errors  & loc [M]     & err/loc \\
        \hline 
        usr     & 2471    & 845          & 290 \% \\
        samples & 2471    & 7,500        & 32\% \\
        include & 2421    & 692,000      & 0.35 \% \\
        drivers & 1405    & 10,800,000   & 0.013 \% \\
        lib     & 99      & 1,050,00     & 0.094 \% \\
        init    & 1       & 5,730        & 0.017 \% \\
        ipc     & 1       & 8,860        & 0.011 \% \\
        net     & 88      & 890,000      & 0.0099 \% \\
        crypto  & 8       & 83,900       & 0.0095 \% \\
        arch/x86 & 26     & 343,000      & 0.0076 \% \\
        scripts & 5       & 90,700       & 0.0055 \% \\
        sound   & 26      & 876,000      & 0.0030 \% \\
        mm      & 3       & 108,000      & 0.0028 \% \\
        fs      & 31      & 1,170,000    & 0.0026 \% \\
        kernel  & 6       & 244,000      & 0.0025 \% \\
        arch    & 26      & 3,440,000    & 0.00076 \% \\
        firmware & 0       & 129,000      & 0.00046 \% \\
        virt    & 0       & 10,500       & 0    \% \\
        tools   & 1       & 218,000      & 0    \% \\
        block   & 0       & 38,100       & 0    \% \\
        security & 0       & 75,500       & 0   \% \\
        \hline
        \hline
    \end{tabular}
\figb{}{}

\figa
    \begin{tabular}{l|r}
        \hline
        \hline
        \textbf{Subsystem} & \textbf{Percent} \\
        \hline
        
        samples & 68\%\\
        usr     & 68\%\\
        include & 67\%\\
        drivers/    &   39\% \\
        lib     & 2.7\%\\
        net     & 2.4\%\\
        fs/         & 0.86\% \\
        sound   & 0.72\%\\
        arch/   & 0.71\%\\
        crypto/ & 0.22\%\\
        kernel  & 0.17\%\\
        scripts & 0.13\%\\
        mm/ & 0.083\% \\
        init    & 0.028\%\\
        ipc     & 0.028\%\\
        security & 0.0\%\\
        block/  & 0.0\%\\

        \hline
        \hline
        
    \end{tabular}
\figb{Percentage of subsystems that were present in errorneous compilations}{}


\section{Analyzing the data}


    \section{Number of valid configurations}

There was a hope, that something could be said about the percentage of valid 
configurations out of all possible combinations.

Some mandatory features were fixed, and an experiment was run, but after 100,000
configurations, none of them were valid. This can only be used to say something
about the upper bound of the percentage.


\section{Observations}


    \subsection{Configuration Warnings}
When creating a random configuration, 25\%
    \footnote{get the correct percentage}
of the times, it will output a warning about unmet dependencies. One might
suspect that configurations, which yielded a warning would result in
compilation errors. 

As can be seen in figure \ref{tbl:confwarns}, fewer of the stable kernels that 
had configuration warnings also had an error in the compilation. But the rise 
in erroneous compilations from configurations without config warnings to 
configurations with config warnings is very little, and is claimed irrelevant.

\figa
    \begin{tabular}{c|c|c}
    \hline
    \hline
        & \textbf{Stable} & \textbf{Unstable} \\
    \hline
    No config warnings & 17\% & 36\%\\
    Config warnings & 19\% & 40\%\\
    \hline
    \hline
    \end{tabular}
\figb{Percentage of the configs with and without warnings, which resulted in an 
    erroneous compilation}{tbl:confwarns}

% TODO
/iffalse
  . write how many bugs/config on average there were.
  . mention that security has none.
/fi


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           THREATS TO VALIDITY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
    \chapter{Threats to Validity}
\label{ch:ttv}

\emph{Blahblah about Threats to validity...}

\section{Generalization}
\label{sec:gen}

One major threat to validity is in the representativeness of the random 
configurations. Since the configurations are created using the \textcode{make 
randconfig} method, some configurations are more likely to be generated than 
others.

This means, that when something is generally said about all of the Linux 
Kernel, instead something is said about mostly a subset of Linuxes. See figure 
\ref{fig:repsubset} for a visualization of subsets which are both 
representative, and not representative.

\figa
    \emph{Show an image of true representativeness}
\figb{A representative subset}{fig:repsubset}

Three ways was thought of, that would make the configurations more 
generalizable. If successful with any of the methods, they could have been 
committed to the Linux kernel. Unfortunately, none of them were successful.


    \subsection*{Changing the code of \texttt{randconfig}}
The first idea was to change the code of \texttt{randconfig}, so it would know
what the possibilities of each outcome should be. See figure 
\ref{randconfigtoy33} for a visualization.

This was deemed impossible due to the very large feature model. The 
\emph{Abstract Syntax Tree (AST)} would simply not fit in memory of any 
computer.
    \footnote{Give short example}


    \subsection*{Permutation of Kconfig files}
Another idea was to take all the spread out Kconfig files, and concatenate 
them all into one big text file, which would then be modified and exposed to 
syntactic desugaring. If the order of the features were randomized, then the 
coins would not be flipped in the same order every time, and this could have an 
effect on the dependent features. 
\\

It turned out, that \texttt{randconfig} does not regard the order of the 
kconfig files. The Kconfig files are loaded, and \texttt{randconfig} then 
utilizes the AST and randomly selects from the root of that, which gives the
same result as when Kconfig is not permuted.


    \subsection*{Generate and Filter}
The third idea was to manually generate a configuration file, and then check - 
somehow - if the config file was valid, and then use it if it was valid. By 
not looking at dependencies, but only considering \emph{choice} options and 
enabling \emph{mandatory features}, a configuration file was created by 
randomly flipping a coin per each feature.

This seemed doable, but after generating 100,000 configurations, not one 
valid configuration was found.

It was considered running \emph{SharpSAT} (or \emph{\#SAT}) to count the number
of valid configurations, but it was deemed out of scope of this project.
    \footnote{Link to sharpSAT thingy}


    \subsection{Features in Stable vs. Unstable}
In the unstable Linux version, there are 20 more features than in the stable 
one. This means that there is a possibility that errors might happen in this 
new code.

Configurations are created in the unstable version, and when the stable version 
runs the same configuration file, it will just disregard these unknown features.
\\

If it was done the other way around, the unstable version would always set the 
new features to the default value, and they would therefore not be randomized.


    \subsection{Gcc versions}
Roughly a third of the compilations were done with GCC version 5.1.0 and two 
thirds with GCC version 4.9.2. This should not matter on what warnings are 
returned. There is only one new warning that is enabled by the \texttt{-Wall} 
flag in version 5.1.0
    \footnote{\texttt{-Wc++14compat}}
, and none of this type was found.


    \subsection{Architecture}

To create a true representative sample space, all the different architectures 
should be compiled for. There exist 31 different architectures, but the most 
common one for laptop and server use is the \texttt{x86} architecture.

This architecture is the only one, that are compiled for in this project, as 
getting the cross compilers for all the different architectures would be very 
cumbersome. 
\\


This potentially leaves out 97\% \footnote{is this number true. Should I 
calculate?} of the possible configurations to check.

\subsection{Firmware}

Some places in the kernel, there are drivers, which rely on some external 
proprietary binary blob, before they can be built. These binaries are not in 
the kernel, but would have to be downloaded specifically and put in certain 
folders in the kernel tree.

These are throwing errors, which are local errors, and therefore invalid. The 
task of getting all the drivers into the kernel tree was too great, so instead, 
those configurations are simply skipped.

This gives another bias in the sample, which now does not contain any 
configurations with these features on.


% --- 19 lines copied from further up
The feature \textcode{CONFIG\_STANDALONE} for instance, has been enabled in all 
the configurations in this project. If this feature is disabled, it allows for 
firmware drivers to be compiled in the kernel. But these firmware drivers are 
not open source, and must be placed in the kernel directories manually for the 
compilation to work.

Since it would be too cumbersome to find all the proprietary drivers, this 
option of enabling the \textcode{CONFIG\_STANDALONE} feature has been chosen, 
and will commit to a threat to validity in respect to representativeness.
\\

Also every feature that had some relation to the \emph{z4c} library has been 
diabled. This would require the host \footnote{explain what a host and target 
are at some point further up} to have this library installed. This library was 
not in the Linux distribution's repository, and it would have been too time 
consuming to have it installed. 

Therefore this also marks as a threat to validity.
% ---- 19 lines

\begin{itemize}
    %\item Only run on x86 architecture
    \item randconfig bias
    %\item firmware blobs
    \item Internal vs. External validity
    \item The mandatory features?
\end{itemize}

\section{Generate'n'Filter}



\begin{itemize}
    \item Uniform distribution
    \item Too low percentage
    \item Get a lower bound on the percentage
    \item sharpSAT?
\end{itemize}

\section{elvisconfig}


\section{RandomSAT}


% TODO
\iffalse
  . Maybe the permutation script can be used elsewhere (Thorsten seemed 
    interested)
  . There are extra features in linux-next.. is that a threat to validity
  . I only have 4-5 different versions of linux-next. That is probably internal 
    validity.
\fi



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           RELATED WORK
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\chapter{Related Work}

% TODO
\iffalse
  . 42 bugs
  . Variability in ...
  . Paper from Iago
  . Fengguang Wu and Intel
\fi



\newpage
\chapter{Conclusion}
\emph{--- Leave empty until the end---}




\newpage
\bibliographystyle{siam}
\bibliography{bib}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           APPENDIX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Appendices}
\section{Kconfig language}
\section{Data}

\end{document}











% Example of Bibliography
\newpage
\bibliography{bibliography}

% Example of Appendix
\begin{appendices}
\chapter{Code}
\lstinputlisting[language=Python]{../temp.py}
\end{appendices}

% Example of a drawing
\begin{figure}[H]
    \begin{center}
        \begin{tikzpicture}
            \draw rectangle (14,4);
            \draw rectangle (7,2);
            \draw (0,2) rectangle (7,2);
            \draw (7,0) rectangle (8,4);

            \foreach \x in {0,...,6} \draw (\x+7, 0) rectangle (\x+7+1, 2);
            \foreach \x in {0,...,6} \draw (\x+7, 2) rectangle (\x+7+1, 4);
            \foreach \x in {0,...,6} \draw (\x+.5, 4.5) node {$S_\x$};

            \draw (-.5,3) node {$b_0$};
            \draw (-.5,1) node {$b_1$};

            % The overbrace
            \draw (10.5, 4.5) node 
            {$\overbrace{\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad}$};
            \draw (10.5,5.0) node {buckets};

            % Signature matrix (left part)
            \draw (0.5,3.5) node {1};
            \draw (0.5,2.5) node {3};
            \draw (0.5,1.5) node {4};
            \draw (0.5,0.5) node {0};

            \draw (1.5,3.5) node {1};
            \draw (1.5,2.5) node {3};
            \draw (1.5,1.5) node {3};
            \draw (1.5,0.5) node {1};

            \draw (2.5,3.5) node {4};
            \draw (2.5,2.5) node {1};
            \draw (2.5,1.5) node {2};
            \draw (2.5,0.5) node {4};

            \draw (3.5,3.5) node {3};
            \draw (3.5,2.5) node {5};
            \draw (3.5,1.5) node {3};
            \draw (3.5,0.5) node {2};

            \draw (4.5,3.5) node {3};
            \draw (4.5,2.5) node {3};
            \draw (4.5,1.5) node {3};
            \draw (4.5,0.5) node {2};

            \draw (5.5,3.5) node {6};
            \draw (5.5,2.5) node {2};
            \draw (5.5,1.5) node {4};
            \draw (5.5,0.5) node {6};

            \draw (6.5,3.5) node {1};
            \draw (6.5,2.5) node {3};
            \draw (6.5,1.5) node {3};
            \draw (6.5,0.5) node {1};

            % Fill all with red (in right part)
            \foreach \x in {0,...,6} \path[fill=red!30] (7.1+\x,0.1) rectangle 
            (7.9+\x,1.9);
            \foreach \x in {0,...,6} \path[fill=red!30] (7.1+\x,2.1) rectangle 
            (7.9+\x,3.9);

            % Fill the right ones with green
            \path[fill=green!50] (7.1,2.1) rectangle (7.9,3.9);
            \path[fill=green!50] (8.1,0.1) rectangle (8.9,1.9);
            \path[fill=green!50] (10.1,0.1) rectangle (10.9,1.9);

            % Names
            \draw (7.5,3.5) node {$S_0$};
            \draw (7.5,3.0) node {$S_1$};
            \draw (7.5,2.5) node {$S_6$};
            \draw (8.5,3.5) node {$S_2$};
            \draw (9.5,3.5) node {$S_3$};
            \draw (10.5,3.5) node {$S_4$};
            \draw (11.5,3.5) node {$S_5$};

            \draw (7.5,1.5) node {$S_0$};
            \draw (8.5,1.5) node {$S_1$};
            \draw (8.5,1.0) node {$S_6$};
            \draw (9.5,1.5) node {$S_2$};
            \draw (10.5,1.5) node {$S_3$};
            \draw (10.5,1.0) node {$S_4$};
            \draw (11.5,1.5) node {$S_5$};


            % Arrows
            \path[-] (8,-.1) edge [bend left] (6.5,-1);
            \path[->] (6.5,-1) edge [bend right] (5,-2);

            % Candidate squares
            \path[fill=green!50] (3.1, -3.5) rectangle (6.9, -2.2);
            \draw (3,-3.6) rectangle (7,-2.1);

            % Candidate signatures
            \draw (4,-2.5) node {$(S_0, S_1)$};
            \draw (4,-3.0) node {$(S_0, S_6)$};
            \draw (6,-3.0) node {$(S_1, S_6)$};
            \draw (6,-2.5) node {$(S_3, S_4)$};

            \draw (5,-4.0) node {Candidate pairs};
            

        \end{tikzpicture}
    \caption{LSH buckets and bands}
    \label{fig:lsh_buckets}
    \end{center}
\end{figure}


% Example of algorithm
\begin{center}   
    \captionof{algorithm}{Locality Sensitive Hashing algorithm}\label{alg:lsh}
    \begin{algorithmic}
    
    \BState \textbf{Calculate signature matrix as in algorithm 
    \ref{alg:minhashing}}\\

    \State $SIG\gets \text{signature matrix}$
    \State $S\gets \text{number of signatures}$
    \State $bucket\_list\gets \text{empty list}$
    \State $B\gets \text{number of bands}$\\

    \BState \emph{Fill the buckets}
    \For{$b_i$ in $i = 0 \ldots B-1$}
        \State $h_i \gets \text{empty dictionary}$
        \State $bucket\_list.append(h_i)$
        \For{$SIG_j[b_i]$ in $j = 0 \ldots S-1$}
            \State $key \gets SIG_j[b_i]$
            \If{$key$ in $h_i$}
                \State $bucket \gets h_i[key]$
            \Else
                \State $bucket \gets \text{empty list}$
            \EndIf
            \State $bucket.append(j)$
        \EndFor
    \EndFor\\

    \State $candidate\_pairs \gets \text{empty set}$
    \ForAll{$h_i$ in $bucket\_list$}
        \ForAll{$key$ in $h_i$}
            \State $bucket \gets h_i[key]$
            \If{$bucket.length > 1$}
                \For{$pair$ in $bucket$}
                    \State $candidate\_pairs.add(pair)$ 
                \EndFor
            \EndIf
        \EndFor        
    \EndFor\\

    \BState \textbf{Calculate similarities from signature matrix as in 
    algorithm \ref{alg:minhashing}, for the candidate pairs.}

    \end{algorithmic}
\end{center}


% Example of a gnuplot input
\begin{figure}[H]
    \begin{center}
        \input{plots/scurve.tex}
        \caption{S-curve - $f(s) = 1 - (1 - s^r)^b$ ; $k = 1000$}
        \label{fig:scurve}
    \end{center}
\end{figure}


% Example of a table
\begin{figure}[H]
    \begin{center}
        \begin{tabular}{c|c|c}
              & Actual & LSH \\
            \hline
            1 & 1.0 & 1.0 \\
            2 & 1.0  & 1.0 \\
            3 & 0.667 & 0.702 \\
            4 & 0.667 & 0.695 \\
            5 & 0.667 & 0.689 \\
            6 & 0.667 & 0.684 \\
            7 & 0.667 & 0.681 \\
            8 & 0.667 & 0.681 \\
            9 & 0.667 & 0.677 \\
            10 & 0.667 & 0.673 
        \end{tabular}
        \caption{Correctness of LSH}
        \label{tab:lsh-correctness}
    \end{center}
\end{figure}


% Example of equation
\begin{equation}
    \frac{B(64;R,r_1,r_2)}{B(1;R,r_1,r_2} \Rightarrow \frac{64 R}{R + 1 - r_1}
    \label{eq:improvementratio}
\end{equation}


% Example of graphic
\begin{figure}[H]
    \begin{center}
        \includegraphics{plots/bbit/bbit.eps}
        \caption{b-Bit storage improvement}
        \label{fig:bbit}
    \end{center}
\end{figure}
